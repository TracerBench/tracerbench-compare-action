"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CANONICALIZE = {
    additionalArguments: arrayOf("string"),
    chromeExecutable: primitive("string"),
    disableDefaultArguments: primitive("boolean"),
    headless: primitive("boolean"),
    stdio: enumOf("inherit", "ignore"),
    url: primitive("string"),
    userDataDir: primitive("string"),
    userDataRoot: primitive("string"),
    cwd: primitive("string"),
    extendEnv: primitive("boolean"),
    env: env(),
};
function primitive(type) {
    return (value, key) => {
        if (typeof value === type) {
            return value;
        }
        return invalidOption(key, type);
    };
}
function enumOf(...tuple) {
    return (value, key) => {
        if (typeof value === "string") {
            if (tuple.includes(value)) {
                return value;
            }
        }
        return invalidOption(key, tuple.map((v) => JSON.stringify(v)).join(" | "));
    };
}
function arrayOf(type) {
    return (array, key) => {
        if (Array.isArray(array)) {
            for (const value of array) {
                if (typeof value !== type) {
                    return invalidOption(key, `${type}[]`);
                }
            }
            return array;
        }
        return invalidOption(key, `${type}[]`);
    };
}
function env() {
    return (value, key) => {
        if (isObject(value)) {
            return value;
        }
        return invalidOption(key, "env");
    };
}
function canonicalizeOptions(options) {
    const canonical = {
        additionalArguments: undefined,
        chromeExecutable: undefined,
        disableDefaultArguments: false,
        headless: false,
        stdio: "ignore",
        url: undefined,
        userDataDir: undefined,
        userDataRoot: undefined,
        cwd: undefined,
        extendEnv: undefined,
        env: undefined,
    };
    if (isObject(options)) {
        for (const key of Object.keys(canonical)) {
            const value = options[key];
            if (value === undefined) {
                continue;
            }
            canonical[key] = CANONICALIZE[key](value, key);
        }
    }
    return canonical;
}
exports.default = canonicalizeOptions;
function isObject(options) {
    return typeof options === "object" && options !== null;
}
function invalidOption(key, type) {
    throw new TypeError(`invalid option ${key} expected value to be ${type}`);
}
//# sourceMappingURL=canonicalizeOptions.js.map