import { cancellableRace, combineRaceCancellation, } from "race-cancellation";
export default function newSessions(send, raceClose) {
    let sessions;
    return [attachSession, detachSession, dispatchEvent];
    function attachSession(sessionId) {
        return (onEvent, onError, onDetach) => {
            if (sessions === undefined) {
                sessions = new Map();
            }
            const [raceDetach, cancel] = cancellableRace();
            sessions.set(sessionId, {
                onDetach() {
                    cancel(`session detached ${sessionId}`);
                    onDetach();
                },
                onError,
                onEvent,
            });
            return [
                attachSession,
                detachSession,
                (method, params, raceCancellation) => {
                    return send(method, params, 
                    // send is already raced against close
                    combineRaceCancellation(raceDetach, raceCancellation), sessionId);
                },
                combineRaceCancellation(raceClose, raceDetach),
            ];
        };
    }
    function detachSession(sessionId) {
        if (sessions === undefined) {
            return;
        }
        const session = sessions.get(sessionId);
        if (session !== undefined) {
            sessions.delete(sessionId);
            session.onDetach();
        }
    }
    function dispatchEvent(sessionId, event, params) {
        if (sessions === undefined) {
            return;
        }
        const session = sessions.get(sessionId);
        if (session !== undefined) {
            try {
                session.onEvent(event, params);
            }
            catch (err) {
                session.onError(err);
            }
        }
    }
}
//# sourceMappingURL=newSessions.js.map