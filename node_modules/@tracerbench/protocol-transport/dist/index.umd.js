(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('race-cancellation')) :
    typeof define === 'function' && define.amd ? define(['exports', 'race-cancellation'], factory) :
    (global = global || self, factory(global.TBProtocolTransport = {}, global.RaceCancellation));
}(this, (function (exports, raceCancellation) { 'use strict';

    function newResponses() {
        let seq = 0;
        const pending = new Map();
        return [usingResponse, resolveResponse];
        function resolveResponse(response) {
            const resolve = pending.get(response.id);
            if (resolve !== undefined) {
                resolve(response);
            }
        }
        async function usingResponse(using) {
            const id = seq++;
            try {
                const [response, resolve] = raceCancellation.oneshot();
                pending.set(id, resolve);
                return await using(id, response);
            }
            finally {
                pending.delete(id);
            }
        }
    }

    /**
     * Creates a AttachJsonRpcTransport function from the specified
     * AttachMessageTransport function.
     *
     * This just handles the JSON RPC part of adapting the message transport.
     *
     * It does not support all of JSON RPC, only whats needed for the DevTools API.
     * The client can only receive notifications and send requests.
     * The client cannot receive requests or send notifications.
     *
     * @param attach a function that attaches the message transport
     * @param debug an optional debug function, should support format string + args like npm debug
     * @param raceCancellation a raceCancellation that is scoped to the transport like Chrome exited
     */
    function newAttachJsonRpcTransport(attach, debug = () => void 0, raceCancellation$1) {
        return (onNotifiction, emitError, emitClose) => {
            const [_raceClose, cancel] = raceCancellation.cancellableRace();
            const raceClose = raceCancellation.combineRaceCancellation(raceCancellation$1, _raceClose);
            const [usingResponse, resolveResponse] = newResponses();
            const sendMessage = attach(onMessage, onClose);
            return [sendRequest, raceClose];
            function onMessage(message) {
                try {
                    const notification = JSON.parse(message);
                    debug("RECV %O", notification);
                    if (notification !== undefined) {
                        if ("id" in notification) {
                            resolveResponse(notification);
                        }
                        else {
                            onNotifiction(notification);
                        }
                    }
                }
                catch (e) {
                    debug("ERROR %O", e);
                    emitError(e);
                }
            }
            function onClose(error) {
                if (error) {
                    debug("CLOSE %O", error);
                    cancel(`transport closed: ${error.message}`);
                }
                else {
                    debug("CLOSE");
                    cancel("transport closed");
                }
                emitClose();
            }
            async function sendRequest(request, sendRaceCancellation) {
                const combinedRaceCancellation = raceCancellation.combineRaceCancellation(raceClose, sendRaceCancellation);
                return await usingResponse(async (id, response) => {
                    request.id = id;
                    debug("SEND %O", request);
                    sendMessage(JSON.stringify(request));
                    return raceCancellation.throwIfCancelled(await combinedRaceCancellation(response));
                });
            }
        };
    }

    function newProtocolError(request, response) {
        const error = new Error(response.error.message);
        error.name = "ProtocolError";
        error.request = request;
        error.response = response;
        return error;
    }
    function isProtocolError(error) {
        return (error.name === "ProtocolError" && "request" in error && "response" in error);
    }

    function newSessions(send, raceClose) {
        let sessions;
        return [attachSession, detachSession, dispatchEvent];
        function attachSession(sessionId) {
            return (onEvent, onError, onDetach) => {
                if (sessions === undefined) {
                    sessions = new Map();
                }
                const [raceDetach, cancel] = raceCancellation.cancellableRace();
                sessions.set(sessionId, {
                    onDetach() {
                        cancel(`session detached ${String(sessionId)}`);
                        onDetach();
                    },
                    onError,
                    onEvent,
                });
                return [
                    attachSession,
                    detachSession,
                    (method, params, raceCancellation$1) => send(method, params, 
                    // send is already raced against close
                    raceCancellation.combineRaceCancellation(raceDetach, raceCancellation$1), sessionId),
                    raceCancellation.combineRaceCancellation(raceClose, raceDetach),
                ];
            };
        }
        function detachSession(sessionId) {
            if (sessions === undefined) {
                return;
            }
            const session = sessions.get(sessionId);
            if (session !== undefined) {
                sessions.delete(sessionId);
                session.onDetach();
            }
        }
        function dispatchEvent(sessionId, event, params) {
            if (sessions === undefined) {
                return;
            }
            const session = sessions.get(sessionId);
            if (session !== undefined) {
                try {
                    session.onEvent(event, params);
                }
                catch (err) {
                    session.onError(err);
                }
            }
        }
    }

    /**
     * Adapts a AttachJsonRpcTransport function to a AttachProtocolTransport function.
     *
     * Adds support for flattened sessions and creates JSON RPC Request object and unwraps Response.
     *
     * @param attach
     */
    function newAttachProtocolTransport(attach) {
        return (onEvent, onError, onClose) => {
            const [sendRequest, raceClose] = attach(onNotification, onError, onClose);
            const [attachSession, detachSession, dispatchEvent] = newSessions(send, raceClose);
            return [attachSession, detachSession, send, raceClose];
            function onNotification(notification) {
                const { method, params, sessionId } = notification;
                if (sessionId === undefined) {
                    onEvent(method, params);
                }
                else {
                    dispatchEvent(sessionId, method, params);
                }
            }
            async function send(method, params, raceCancellation, sessionId) {
                const request = {
                    method,
                    params,
                    sessionId,
                };
                const response = await sendRequest(request, raceCancellation);
                if ("error" in response) {
                    throw newProtocolError(request, response);
                }
                return response.result;
            }
        };
    }

    function newAttachProtocolTransport$1(attach, debug = () => void 0, raceCancellation) {
        return newAttachProtocolTransport(newAttachJsonRpcTransport(attach, debug, raceCancellation));
    }

    exports.default = newAttachProtocolTransport$1;
    exports.isProtocolError = isProtocolError;
    exports.newAttachJsonRpcTransport = newAttachJsonRpcTransport;
    exports.newAttachProtocolTransport = newAttachProtocolTransport;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
