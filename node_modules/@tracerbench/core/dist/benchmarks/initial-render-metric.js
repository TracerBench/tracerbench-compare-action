"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const trace_event_1 = require("../trace/trace-event");
const util_1 = require("../util");
// going to count blink_gc time as js time since it is wrappers
// that support js like dom nodes.
const IS_V8_CAT = /(?:^|,)(?:disabled-by-default-)?v8(?:[,.]|$)/;
const IS_BLINK_GC_CAT = /(?:^|,)(?:disabled-by-default-)?blink_gc(?:[,.]|$)/;
class InitialRenderMetric {
    constructor(markers, params) {
        this.markers = markers;
        this.phaseEvents = [];
        this.firstEvent = undefined;
        this.paintEvent = undefined;
        this.lastEnd = 0;
        this.start = 0;
        this.end = 0;
        this.duration = 0;
        this.js = 0;
        this.phases = [];
        this.gc = [];
        this.blinkGC = [];
        this.runtimeCallStats = undefined;
        if (params.runtimeStats) {
            this.runtimeCallStats = {};
        }
    }
    measure(trace) {
        const { mainProcess } = trace;
        if (!mainProcess) {
            throw new Error('unable to determine main process for trace');
        }
        const { mainThread } = mainProcess;
        if (!mainThread) {
            throw new Error('unable to determine main thread for process');
        }
        this.findMarkerEvents(mainThread.events);
        this.addPhaseSamples();
        this.addV8Samples(mainProcess.events);
        return {
            duration: this.duration,
            js: this.js,
            phases: this.phases,
            gc: this.gc,
            blinkGC: this.blinkGC,
            runtimeCallStats: this.runtimeCallStats
        };
    }
    findMarkerEvents(events) {
        const markers = this.markers;
        const phaseEvents = [];
        let eventIdx = 0;
        for (const marker of markers) {
            let markEvent;
            for (; eventIdx < events.length; eventIdx++) {
                const event = events[eventIdx];
                if (event.ph === trace_event_1.TRACE_EVENT_PHASE_MARK &&
                    event.name === marker.start) {
                    markEvent = event;
                    break;
                }
            }
            if (markEvent === undefined) {
                throw new Error(`Could not find mark "${marker.start}" in trace`);
            }
            else {
                phaseEvents.push(markEvent);
            }
        }
        const firstEvent = phaseEvents[0];
        let paintEvent;
        for (; eventIdx < events.length; eventIdx++) {
            const event = events[eventIdx];
            if (event.ph === trace_event_1.TRACE_EVENT_PHASE_COMPLETE && event.name === 'Paint') {
                paintEvent = event;
                break;
            }
        }
        if (!paintEvent) {
            throw new Error(`Could not find Paint after last mark`);
        }
        phaseEvents.push(paintEvent);
        this.firstEvent = phaseEvents[0];
        this.phaseEvents = phaseEvents;
        this.paintEvent = paintEvent;
        this.start = firstEvent.ts;
        this.end = paintEvent.ts;
        this.duration = paintEvent.ts - firstEvent.ts;
    }
    addPhaseSamples() {
        const { markers, phaseEvents, start } = this;
        for (let i = 0; i < phaseEvents.length - 1; i++) {
            const marker = markers[i];
            const beginEvent = phaseEvents[i];
            const endEvent = phaseEvents[i + 1];
            this.phases.push({
                phase: marker.label,
                start: beginEvent.ts - start,
                duration: endEvent.ts - beginEvent.ts
            });
        }
    }
    addV8Samples(events) {
        const { start, end } = this;
        this.lastEnd = start;
        for (const event of events) {
            const { ts, dur } = event;
            const eventStart = ts;
            const eventEnd = ts + (dur === undefined ? 0 : dur);
            if (start > eventEnd) {
                continue;
            }
            if (eventStart >= end) {
                break;
            }
            if (isV8(event)) {
                this.addV8Sample(event);
            }
            else if (isBlinkGC(event)) {
                this.addBlinkGC(event);
            }
        }
    }
    addV8Sample(event) {
        this.addRuntimeCallStats(event);
        this.addGCSample(event);
        this.addJSTime(event);
    }
    addJSTime(event) {
        // js sample is all v8 or blink gc events with duration
        // during the duration sample period (clipped if overlap)
        // on any thread for the process (main, web workers, service worker)
        // the idea is to give an idea of the portion of the duration sample
        // that is js related
        if (!isCompleteEvent(event)) {
            return;
        }
        const { lastEnd } = this;
        const { ts, dur } = event;
        // start is event start or the last end of js time
        const start = Math.max(ts, lastEnd);
        // end is event end or the end of our sample duration
        const end = Math.min(ts + dur, this.end);
        if (start < end) {
            this.js += end - start;
            this.lastEnd = end;
        }
    }
    addRuntimeCallStats(event) {
        const { runtimeCallStats } = this;
        if (!runtimeCallStats) {
            return;
        }
        const { args } = event;
        if (!isRuntimeCallStatsArgs(args)) {
            return;
        }
        const runtimeCallStatsArg = args['runtime-call-stats'];
        for (const name of Object.keys(runtimeCallStatsArg)) {
            const [count, time] = runtimeCallStatsArg[name];
            const group = util_1.runtimeCallStatGroup(name);
            let statGroup = runtimeCallStats[group];
            if (statGroup === undefined) {
                statGroup = runtimeCallStats[group] = {};
            }
            const stat = statGroup[name];
            if (stat === undefined) {
                statGroup[name] = { count, time };
            }
            else {
                stat.count += count;
                stat.time += time;
            }
        }
    }
    addGCSample(event) {
        const { start } = this;
        if ((event.ph !== trace_event_1.TRACE_EVENT_PHASE_INSTANT &&
            event.name !== 'MinorGC' &&
            event.name !== 'MajorGC') ||
            event.args === '__stripped__') {
            return;
        }
        this.gc.push({
            kind: event.name,
            type: event.name === 'MinorGC' ? 'scavenge' : event.args.type,
            start: event.ts - start,
            duration: event.dur,
            usedHeapSizeAfter: event.args.usedHeapSizeAfter,
            usedHeapSizeBefore: event.args.usedHeapSizeBefore
        });
    }
    addBlinkGC(event) {
        this.addJSTime(event);
        if (isCompleteEvent(event)) {
            this.blinkGC.push({
                start: event.ts - this.start,
                duration: event.dur
            });
        }
    }
}
exports.default = InitialRenderMetric;
function isRuntimeCallStatsArgs(args) {
    if (args === '__stripped__') {
        return false;
    }
    const runtimeCallStats = args['runtime-call-stats'];
    return typeof runtimeCallStats === 'object' && runtimeCallStats !== null;
}
function isCompleteEvent(event) {
    return event.ph === trace_event_1.TRACE_EVENT_PHASE_COMPLETE;
}
function isV8(event) {
    return IS_V8_CAT.test(event.cat);
}
function isBlinkGC(event) {
    return IS_BLINK_GC_CAT.test(event.cat);
}
//# sourceMappingURL=initial-render-metric.js.map