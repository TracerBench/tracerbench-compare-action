import { IBenchmarkMeta } from '../benchmark';
import Trace from '../trace/trace';
import { ITraceEvent, TRACE_EVENT_PHASE_COMPLETE } from '../trace/trace-event';
export interface IMarker {
    /**
     * performance.mark name
     */
    start: string;
    /**
     * Label of phase
     */
    label: string;
}
export declare type V8GCKind = 'MinorGC' | 'MajorGC';
export declare type V8GCType = 'scavenge' | 'incremental marking' | 'atomic pause' | 'weak processing';
export interface IV8GCSample {
    kind: V8GCKind;
    type: V8GCType;
    start: number;
    duration: number;
    usedHeapSizeBefore: number;
    usedHeapSizeAfter: number;
}
export interface IBlinkGCSample {
    start: number;
    duration: number;
}
export interface IRuntimeCallStats {
    [group: string]: IRuntimeCallStatGroup | undefined;
}
export interface IRuntimeCallStatGroup {
    [stat: string]: IRuntimeCallStat | undefined;
}
export interface IRuntimeCallStat {
    /**
     * count of stat
     */
    count: number;
    /**
     * time in microseconds
     */
    time: number;
}
export interface IIterationSample {
    /**
     * Microseconds from start mark until the start of the first Paint event after the last mark.
     */
    duration: number;
    /**
     * Non overlapping microseconds spent in a V8 event or blink_gc during
     * the duration period.
     */
    js: number;
    /**
     * Samples for phases duration the iteration.
     */
    phases: IPhaseSample[];
    /**
     * Samples of V8 GC during trace.
     */
    gc: IV8GCSample[];
    /**
     * Samples of Blink GC during trace.
     */
    blinkGC: IBlinkGCSample[];
    /**
     * Runtime call stats.
     *
     * Present if param.runtimeStats enabled.
     */
    runtimeCallStats?: IRuntimeCallStats;
}
export interface IGCStat {
    /**
     * json string of stats object
     */
    live: string;
    /**
     * json string of stats object
     */
    dead: string;
}
export interface IInitialRenderSamples {
    meta: IBenchmarkMeta;
    set: string;
    samples: IIterationSample[];
}
export interface IPhaseSample {
    /**
     * Name of phase as defined by the label property of the marker config.
     */
    phase: string;
    /**
     * The start of the phase.
     */
    start: number;
    /**
     * The duration in microseconds of the phase.
     */
    duration: number;
}
export default class InitialRenderMetric {
    private markers;
    protected phaseEvents: ITraceEvent[];
    protected firstEvent: ITraceEvent | undefined;
    protected paintEvent: ITraceEvent | undefined;
    protected lastEnd: number;
    protected start: number;
    protected end: number;
    protected duration: number;
    protected js: number;
    protected phases: IPhaseSample[];
    protected gc: IV8GCSample[];
    protected blinkGC: IBlinkGCSample[];
    protected runtimeCallStats: IRuntimeCallStats | undefined;
    constructor(markers: IMarker[], params: {
        runtimeStats?: boolean;
    });
    measure(trace: Trace): IIterationSample;
    findMarkerEvents(events: ITraceEvent[]): void;
    addPhaseSamples(): void;
    protected addV8Samples(events: ITraceEvent[]): void;
    protected addV8Sample(event: IV8Event): void;
    protected addJSTime(event: IBlinkGCEvent | IV8Event): void;
    protected addRuntimeCallStats(event: IV8Event): void;
    protected addGCSample(event: IV8Event): void;
    protected addBlinkGC(event: IBlinkGCEvent): void;
}
export interface IV8Event extends ITraceEvent {
    cat: 'v8';
}
export interface IV8CompleteEvent extends IV8Event {
    ph: TRACE_EVENT_PHASE_COMPLETE;
    dur: number;
}
export interface IBlinkGCEvent extends ITraceEvent {
    cat: 'blink_gc';
}
export interface IBlinkGCCompleteEvent extends IBlinkGCEvent {
    ph: TRACE_EVENT_PHASE_COMPLETE;
    dur: number;
}
//# sourceMappingURL=initial-render-metric.d.ts.map