"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../trace/utils");
const is_navigation_timing_mark_1 = require("./is-navigation-timing-mark");
async function injectMarkObserver(page, mark, variable = '__tracerbench') {
    const scriptSource = (0, is_navigation_timing_mark_1.default)(mark)
        ? navigationObserver(variable)
        : markObserver(mark, variable);
    await page.send('Page.addScriptToEvaluateOnLoad', {
        scriptSource
    });
    return (raceCancelation) => waitForMark(page, variable, mark, raceCancelation);
}
exports.default = injectMarkObserver;
function markObserver(mark, variable) {
    return `"use strict";
  ${utils_1.enforcePaintEventFn}
var ${variable} =
  self === top &&
  opener === null &&
  new Promise((resolve) =>
    new PerformanceObserver((records, observer) => {
      if (records.getEntriesByName(${JSON.stringify(mark)}).length > 0) {
        requestAnimationFrame(() => {
          enforcePaintEvent();
          requestIdleCallback(() => {
            performance.mark("endTrace");
            resolve();
          });
        });
        observer.disconnect();
      }
    }).observe({ type: "mark" })
  );`;
}
function navigationObserver(variable) {
    return `"use strict";
  ${utils_1.enforcePaintEventFn}
var ${variable} =
  self === top &&
  opener === null &&
  new Promise((resolve) =>
    new PerformanceObserver((records, observer) => {
      if (records.getEntries().length > 0) {
        requestAnimationFrame(() => {
          enforcePaintEvent();
          requestIdleCallback(() => {
            performance.mark("endTrace");
            resolve();
          });
        });
        observer.disconnect();
      }
    }).observe({ type: "navigation" })
  );`;
}
async function waitForMark(page, expression, mark, raceCancelation) {
    let result;
    try {
        result = await page.send('Runtime.evaluate', {
            expression,
            awaitPromise: true,
            returnByValue: true
        }, raceCancelation);
        const { exceptionDetails } = result;
        if (exceptionDetails !== undefined) {
            throw waitForMarkError(mark, { exceptionDetails });
        }
    }
    catch (original) {
        if (original instanceof Error) {
            throw waitForMarkError(mark, { original });
        }
        else {
            throw original;
        }
    }
}
function waitForMarkError(mark, { original, exceptionDetails }) {
    let message = `errored while waiting for ${mark}`;
    if (exceptionDetails) {
        message += `: ${exceptionDetails.text}`;
    }
    if (original) {
        message += `: ${original.message}`;
    }
    const error = new Error(message);
    error.exceptionDetails = exceptionDetails;
    error.original = original;
    return error;
}
//# sourceMappingURL=inject-mark-observer.js.map