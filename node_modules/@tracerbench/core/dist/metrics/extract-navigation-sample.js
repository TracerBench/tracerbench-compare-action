"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function extractNavigationSample(trace, markers) {
    const mainProcess = trace.processes.find((p) => p.isRenderer);
    if (mainProcess === undefined) {
        throw new Error(`missing main process`);
    }
    const phases = findPhases(mainProcess.events, markers);
    const lastPhase = phases[phases.length - 1];
    return {
        metadata: trace.metadata,
        duration: lastPhase.start + lastPhase.duration,
        phases
    };
}
exports.default = extractNavigationSample;
function findPhases(events, markers) {
    const phaseEvents = [];
    let eventIdx = 0;
    let navigationStartArgs;
    // for each marker scan forward in the events to find it
    for (const marker of markers) {
        let markEvent;
        for (; eventIdx < events.length; eventIdx++) {
            const event = events[eventIdx];
            if (event.isMark()) {
                if (navigationStartArgs === undefined) {
                    if (event.name === 'navigationStart') {
                        if (event.args === undefined) {
                            throw new Error(`navigationStart mark event is missing args`);
                        }
                        navigationStartArgs = event.args;
                    }
                    if (marker.start === 'navigationStart') {
                        markEvent = event;
                        break;
                    }
                }
                else {
                    if (event.name === marker.start) {
                        const { args } = event;
                        // ensure this belongs to this navigation
                        if (isNavigationTimingArgs(args)) {
                            // if it is a navigation timing API mark
                            // it should match the start frame
                            if (args.frame === navigationStartArgs.frame) {
                                markEvent = event;
                                break;
                            }
                        }
                        else if (isUserTimingArgs(args)) {
                            // if the mark is a user timing mark
                            // performance.mark("my mark")
                            // it should have a navigationId to match this one
                            if (args.data.navigationId === navigationStartArgs.data.navigationId) {
                                markEvent = event;
                                break;
                            }
                        }
                    }
                }
            }
        }
        if (markEvent === undefined) {
            throw new Error(`Could not find mark "${marker.start}" in trace`);
        }
        else {
            phaseEvents.push(markEvent);
        }
    }
    let paintEvent;
    for (; eventIdx < events.length; eventIdx++) {
        const event = events[eventIdx];
        if (event.isComplete() && event.name === 'Paint') {
            paintEvent = event;
            break;
        }
    }
    if (!paintEvent) {
        throw new Error(`Could not find Paint event in trace after last mark "${markers[markers.length - 1].start}"`);
    }
    const phases = [];
    const start = phaseEvents[0].start;
    for (let i = 0; i < phaseEvents.length; i++) {
        const marker = markers[i];
        const markEvent = phaseEvents[i];
        const end = i + 1 < phaseEvents.length ? phaseEvents[i + 1].start : paintEvent.end;
        phases.push({
            phase: marker.label,
            start: markEvent.start - start,
            duration: end - markEvent.start
        });
    }
    return phases;
}
function isNavigationTimingArgs(args) {
    return args !== undefined && typeof args.frame === 'string';
}
function isUserTimingArgs(args) {
    return (args !== undefined &&
        typeof args.data === 'object' &&
        args.data !== null &&
        'navigationId' in args.data);
}
//# sourceMappingURL=extract-navigation-sample.js.map