"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../trace/utils");
function extractNavigationSample(trace, markers) {
    const mainProcess = trace.processes.find((p) => p.isRenderer);
    if (mainProcess === undefined) {
        throw new Error(`missing main process`);
    }
    const phases = findPhases(mainProcess.events, markers);
    const lastPhase = phases[phases.length - 1];
    return {
        metadata: trace.metadata,
        duration: lastPhase.start + lastPhase.duration,
        phases
    };
}
exports.default = extractNavigationSample;
function findPhases(events, markers) {
    const phaseEvents = [];
    let eventIdx = 0;
    let navigationStartArgs;
    const traceEndAtLcp = (0, utils_1.isTraceEndAtLCP)(markers);
    // for each marker scan forward in the events to find it
    for (const marker of markers) {
        let markEvent;
        for (; eventIdx < events.length; eventIdx++) {
            const event = events[eventIdx];
            // Chrome 90 change of phase event from R to I for navigationStart
            if (event.isMark() || event.isInstant()) {
                if (navigationStartArgs === undefined) {
                    if (event.name === 'navigationStart') {
                        if (event.args === undefined) {
                            throw new Error(`navigationStart mark event is missing args`);
                        }
                        navigationStartArgs = event.args;
                    }
                    if (marker.start === 'navigationStart') {
                        markEvent = event;
                        break;
                    }
                }
                else {
                    if (event.name === marker.start) {
                        const { args } = event;
                        // ensure this belongs to this navigation
                        if (isNavigationTimingArgs(args)) {
                            // if it is a navigation timing API mark
                            // it should match the start frame
                            if (args.frame === navigationStartArgs.frame) {
                                markEvent = event;
                                break;
                            }
                        }
                        else if (isUserTimingArgs(args)) {
                            // if the mark is a user timing mark
                            // performance.mark("my mark")
                            // it should have a navigationId to match this one
                            if (args.data.navigationId === navigationStartArgs.data.navigationId) {
                                markEvent = event;
                                break;
                            }
                        }
                    }
                }
            }
        }
        if (markEvent === undefined) {
            throw new Error(`Could not find mark "${marker.start}" in trace`);
        }
        else {
            phaseEvents.push(markEvent);
        }
    }
    let paintEvent;
    for (; eventIdx < events.length; eventIdx++) {
        const event = events[eventIdx];
        if ((event.isComplete() && event.name === 'Paint') ||
            (event.isMark() && event.name === utils_1.LCP_EVENT_NAME && traceEndAtLcp)) {
            paintEvent = event;
            break;
        }
    }
    if (!paintEvent) {
        throw new Error(`Could not find Paint event or ${utils_1.LCP_EVENT_NAME} in trace after last mark "${markers[markers.length - 1].start}. The last marker should trigger a paint event."`);
    }
    const phases = [];
    const start = phaseEvents[0].start;
    let end = phaseEvents[0].end;
    for (let i = 0; i < phaseEvents.length; i++) {
        const marker = markers[i];
        const markEvent = phaseEvents[i];
        if (i + 1 < phaseEvents.length) {
            //skip LCP if user configure the LCP in the middle of marker list
            if ((0, utils_1.isLCPEvent)(markEvent.name)) {
                continue;
            }
            end = phaseEvents[i + 1].start;
        }
        else {
            //skip if paint event is LCP event, do not double count the phases
            if ((0, utils_1.isLCPEvent)(paintEvent.name)) {
                continue;
            }
            end = paintEvent.end;
        }
        phases.push({
            phase: marker.label,
            start: markEvent.start - start,
            duration: end - markEvent.start
        });
    }
    return phases;
}
function isNavigationTimingArgs(args) {
    return args !== undefined && typeof args.frame === 'string';
}
function isUserTimingArgs(args) {
    return (args !== undefined &&
        typeof args.data === 'object' &&
        args.data !== null &&
        'navigationId' in args.data);
}
//# sourceMappingURL=extract-navigation-sample.js.map