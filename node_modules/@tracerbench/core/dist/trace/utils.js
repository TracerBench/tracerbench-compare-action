"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enforcePaintEventFn = exports.setCookies = exports.emulate = exports.getTab = exports.getNewTab = exports.createBrowser = exports.filterObjectByKeys = exports.wait = exports.getBrowserArgs = void 0;
const chrome_debugging_client_1 = require("chrome-debugging-client");
const tmp_1 = require("tmp");
const conditions_1 = require("./conditions");
/* eslint-disable @typescript-eslint/no-explicit-any */
function getBrowserArgs(explictArgs) {
    const tmpDir = (0, tmp_1.dirSync)({
        unsafeCleanup: true
    });
    const options = {
        windowSize: {
            width: 1280,
            height: 800
        },
        deviceScaleFactor: 0,
        userAgent: undefined
    };
    let defaultFlags = [
        `--crash-dumps-dir=${tmpDir.name}`,
        '--disable-background-networking',
        '--disable-background-timer-throttling',
        '--disable-backgrounding-occluded-windows',
        '--disable-component-extensions-with-background-pages',
        '--disable-client-side-phishing-detection',
        '--disable-default-apps',
        '--disable-dev-shm-usage',
        '--disable-domain-reliability',
        '--disable-extensions',
        '--disable-features=NetworkPrediction',
        '--disable-features=site-per-process,TranslateUI,BlinkGenPropertyTrees',
        '--disable-hang-monitor',
        '--disable-ipc-flooding-protection',
        '--disable-notifications',
        '--disable-renderer-backgrounding',
        '--disable-sync',
        '--disable-translate',
        '--disable-v8-idle-tasks',
        `--device-scale-factor=${options.deviceScaleFactor}`,
        '--metrics-recording-only',
        '--no-pings',
        '--no-first-run',
        '--no-default-browser-check',
        '--no-experiments',
        '--no-sandbox',
        '--password-store=basic',
        '--safebrowsing-disable-auto-update',
        '--use-mock-keychain',
        `--user-agent=${options.userAgent}`,
        `--user-data-dir=${tmpDir.name}`,
        '--v8-cache-options=none',
        `--window-size=${options.windowSize.width},${options.windowSize.height}`
    ];
    defaultFlags = explictArgs ? explictArgs.concat(defaultFlags) : defaultFlags;
    return defaultFlags;
}
exports.getBrowserArgs = getBrowserArgs;
async function wait(dur) {
    return new Promise((resolve) => {
        setTimeout(resolve, dur);
    });
}
exports.wait = wait;
function filterObjectByKeys(obj, keyArray) {
    const o = Object.assign({}, obj);
    const k = Object.keys(o);
    k.forEach((c) => {
        if (!keyArray.includes(c)) {
            delete o[c];
        }
    });
    return o;
}
exports.filterObjectByKeys = filterObjectByKeys;
async function createBrowser(browserArgs = [], headless = false) {
    const browser = await (0, chrome_debugging_client_1.spawnChrome)({
        additionalArguments: browserArgs,
        stdio: headless ? 'ignore' : 'inherit',
        chromeExecutable: undefined,
        userDataDir: undefined,
        userDataRoot: undefined,
        url: undefined,
        disableDefaultArguments: false,
        headless
    });
    return browser;
}
exports.createBrowser = createBrowser;
async function getNewTab(browser, url = 'about:blank') {
    const { targetId } = await browser.send('Target.createTarget', {
        url
    });
    return await browser.attachToTarget(targetId);
}
exports.getNewTab = getNewTab;
async function getTab(browser) {
    // const tabs = await apiClient.send();
    // create one tab at about:blank
    const { targetId } = await browser.send('Target.createTarget', {
        url: 'about:blank'
    });
    const tab = browser.connection(await browser.send('Target.attachToTarget', {
        targetId,
        flatten: true
    }));
    if (!tab) {
        throw Error('failed to attach to target');
    }
    // close other page targets
    const { targetInfos } = await browser.send('Target.getTargets');
    for (const targetInfo of targetInfos) {
        if (targetInfo.type === 'page' && targetInfo.targetId !== targetId) {
            await browser.send('Target.closeTarget', {
                targetId: targetInfo.targetId
            });
        }
    }
    await browser.send('Target.activateTarget', { targetId });
    return tab;
}
exports.getTab = getTab;
async function emulate(client, conditions) {
    // tells whether emulation is supported
    const { result: canEmulate } = await client.send('Emulation.canEmulate');
    if (canEmulate) {
        await client.send('Emulation.setCPUThrottlingRate', {
            rate: conditions.cpu
        });
    } // throw error if configured to emulate and returned false
    // needs to ensure Network.enable
    const { result: canEmulateNetworkConditions } = await client.send('Network.canEmulateNetworkConditions');
    if (conditions.network !== undefined && canEmulateNetworkConditions) {
        const networkCondition = conditions_1.networkConditions[conditions.network];
        if (networkCondition) {
            await client.send('Network.emulateNetworkConditions', networkCondition);
        }
        else {
            throw new Error(`Could not find network emulation "${conditions.network}"`);
        }
    }
}
exports.emulate = emulate;
async function setCookies(page, cookies) {
    for (let i = 0; i < cookies.length; i++) {
        const cookie = filterObjectByKeys(cookies[i], ['name', 'value', 'domain']);
        try {
            await page.send('Network.setCookie', cookie);
        }
        catch (error) {
            throw new Error(`${error}. CookieParam format invalid: https://chromedevtools.github.io/devtools-protocol/tot/Network#type-CookieParam.`);
        }
    }
}
exports.setCookies = setCookies;
// adopted from https://github.com/Modernizr/Modernizr/blob/master/test/browser/src/mq.js#L29
exports.enforcePaintEventFn = `
function enforcePaintEvent() {

  const docElem = document.documentElement;
  const refNode = docElem.firstElementChild;
  const fakeBody = document.createElement('body');
  const div = document.createElement('div');

  div.id = 'mq-test-1';
  div.style.cssText = 'position:absolute;top:-100em';
  fakeBody.style.background = 'none';
  fakeBody.appendChild(div);
  div.innerHTML = '&shy;<style> #mq-test-1 { width: 42px; }</style>';
  docElem.insertBefore(fakeBody, refNode);

  try {
      return div.offsetWidth === 42;
  } finally {
      fakeBody.removeChild(div);
      docElem.removeChild(fakeBody);
  }

}
`;
//# sourceMappingURL=utils.js.map