"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EOF = -1;
class ParsedFile {
    constructor(content) {
        this.content = content;
        this.lines = [];
        this.moduleLocators = new Map();
        this.mangledDefine = findMangledDefine(this.content);
        this.lines = this.content.split('\n');
    }
    moduleNameFor(callFrame) {
        const { lineNumber, columnNumber, functionName } = callFrame;
        const key = `${lineNumber}${columnNumber}${functionName}`;
        const moduleLocator = this.moduleLocators.get(key);
        if (moduleLocator) {
            return moduleLocator.name;
        }
        const name = this.findModuleName(lineNumber);
        this.moduleLocators.set(key, {
            name,
            callFrames: [callFrame]
        });
        return name;
    }
    findModuleName(line) {
        if (line === EOF) {
            return 'unknown';
        }
        const currentLine = this.lines[line];
        const defineIndex = getModuleIndex(currentLine, 'define');
        const mangledIndex = getModuleIndex(currentLine, this.mangledDefine);
        if (defineIndex === EOF && mangledIndex === EOF) {
            return this.findModuleName(line - 1);
        }
        let ident;
        let index;
        if (defineIndex > EOF) {
            ident = 'define';
            index = defineIndex;
        }
        else {
            ident = this.mangledDefine;
            index = mangledIndex;
        }
        return extractModuleName(currentLine, ident, index);
    }
}
exports.ParsedFile = ParsedFile;
function findMangledDefine(content) {
    // finds the internal loader ident index
    const tail = content.indexOf('.__loader.define');
    const sub = content.slice(0, tail);
    let defineToken = '';
    let end = sub.length - 1;
    let scanning = true;
    let declaration = false;
    while (scanning) {
        const char = sub[end--];
        switch (char) {
            case '=':
                declaration = true;
                break;
            case ' ':
                scanning = false;
                break;
            default:
                if (declaration) {
                    defineToken = char + defineToken;
                }
                break;
        }
    }
    return defineToken;
}
exports.findMangledDefine = findMangledDefine;
function getModuleIndex(str, ident) {
    let matcher;
    // todo this is a temporary workaround as findMangledDefine is not working as intended and needs ASAP deep debug
    try {
        matcher = new RegExp(`(?:${ident}\\(")(.*?)(?=",\\[\\"(.*)\\"],(function|\\(function))`, 'g');
    }
    catch (error) {
        try {
            matcher = new RegExp(`(?:''\\(")(.*?)(?=",\\[\\"(.*)\\"],(function|\\(function))`, 'g');
        }
        catch (error) {
            throw new Error(error);
        }
    }
    const matches = str.match(matcher);
    if (matches === null) {
        return EOF;
    }
    const lastMatched = matches[matches.length - 1];
    return str.indexOf(lastMatched);
}
exports.getModuleIndex = getModuleIndex;
function extractModuleName(line, token, index) {
    let start = index + `${token}("`.length;
    let moduleName = '';
    let char;
    while (char !== '"') {
        char = line[start];
        moduleName += char;
        start++;
        char = line[start];
    }
    return moduleName;
}
exports.extractModuleName = extractModuleName;
//# sourceMappingURL=metadata.js.map