"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const trace_1 = require("./trace/trace");
class Tab {
    constructor(id, browser, page, frame) {
        this.isTracing = false;
        /**
         * Called when the frame navigates
         */
        this.onNavigate = undefined;
        this.id = id;
        this.browser = browser;
        this.page = page;
        this.frame = frame;
        page.on('Page.frameNavigated', (params) => {
            const newFrame = params.frame;
            if (!newFrame.parentId) {
                this.frame = newFrame;
                if (this.onNavigate) {
                    this.onNavigate();
                }
            }
        });
    }
    /**
     * Navigates to the specified url
     */
    async navigate(url, shouldWaitForLoad) {
        const { frame, page } = this;
        await Promise.all([maybeWaitForLoad(), load()]);
        async function maybeWaitForLoad() {
            if (shouldWaitForLoad) {
                await page.until('Page.frameStoppedLoading', ({ frameId }) => frameId === frame.id);
            }
        }
        async function load() {
            if (frame.url === url) {
                await page.send('Page.reload', {});
            }
            else {
                await page.send('Page.navigate', { url });
            }
        }
    }
    async addScriptToEvaluateOnLoad(scriptSource) {
        const result = await this.page.send('Page.addScriptToEvaluateOnLoad', {
            scriptSource
        });
        return result.identifier;
    }
    async removeScriptToEvaluateOnLoad(identifier) {
        await this.page.send('Page.removeScriptToEvaluateOnLoad', { identifier });
    }
    /** Start tracing */
    async startTracing(categories, options) {
        if (this.isTracing) {
            throw new Error('already tracing');
        }
        this.isTracing = true;
        const { page } = this;
        const traceComplete = (async () => {
            const trace = new trace_1.default();
            const onDataCollected = ({ value }) => {
                trace.addEvents(value);
            };
            page.on('Tracing.dataCollected', onDataCollected);
            await page.until('Tracing.tracingComplete');
            this.isTracing = false;
            page.removeListener('Tracing.dataCollected', onDataCollected);
            trace.buildModel();
            /*
              Chrome creates a new Renderer with a new PID each time we open a new tab,
              but the old PID and Renderer processes continues to hang around. Checking
              the length of the events array helps us to ensure we find the active tab's
              Renderer process.
            */
            trace.mainProcess = trace.processes
                .filter((p) => p.name === 'Renderer')
                .reduce((c, v) => (v.events.length > c.events.length ? v : c));
            return trace;
        })();
        const end = async () => {
            if (this.isTracing) {
                await page.send('Tracing.end');
            }
        };
        await page.send('Tracing.start', { categories, options });
        return { end, traceComplete };
    }
    /** Clear browser cache and memory cache */
    async clearBrowserCache() {
        const { page } = this;
        await page.send('Network.enable', { maxTotalBufferSize: 0 });
        const res = await page.send('Network.canClearBrowserCache');
        if (!res.result) {
            throw new Error('Cannot clear browser cache');
        }
        await page.send('Network.clearBrowserCache');
        // causes MemoryCache entries to be evicted
        await page.send('Network.setCacheDisabled', { cacheDisabled: true });
        // await page.send('Network.disable');
    }
    async setCPUThrottlingRate(rate) {
        await this.page.send('Emulation.setCPUThrottlingRate', { rate });
    }
    async emulateNetworkConditions(conditions) {
        await this.page.send('Network.enable', {
            maxResourceBufferSize: 0,
            maxTotalBufferSize: 0
        });
        await this.page.send('Network.emulateNetworkConditions', conditions);
    }
    async disableNetworkEmulation() {
        await this.page.send('Network.emulateNetworkConditions', {
            downloadThroughput: 0,
            latency: 0,
            offline: false,
            uploadThroughput: 0
        });
        await this.page.send('Network.disable');
    }
    async collectGarbage() {
        const { page } = this;
        await page.send('HeapProfiler.enable');
        await page.send('HeapProfiler.collectGarbage');
        await page.send('HeapProfiler.disable');
    }
    async emulateDevice(deviceSettings) {
        await this.page.send('Emulation.setDeviceMetricsOverride', deviceSettings);
    }
    async setUserAgent(userAgentSettings) {
        await this.page.send('Emulation.setUserAgentOverride', userAgentSettings);
    }
}
function createTab(id, browser, tab, frame) {
    return new Tab(id, browser, tab, frame);
}
exports.default = createTab;
//# sourceMappingURL=tab.js.map