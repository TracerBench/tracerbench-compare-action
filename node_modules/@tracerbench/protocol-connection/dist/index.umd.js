(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@tracerbench/protocol-transport'), require('race-cancellation')) :
    typeof define === 'function' && define.amd ? define(['exports', '@tracerbench/protocol-transport', 'race-cancellation'], factory) :
    (global = global || self, factory(global.TBProtocolConnection = {}, global.TBProtocolTransport, global.RaceCancellation));
}(this, (function (exports, newAttachProtocolTransport, raceCancellation) { 'use strict';

    newAttachProtocolTransport = newAttachProtocolTransport && Object.prototype.hasOwnProperty.call(newAttachProtocolTransport, 'default') ? newAttachProtocolTransport['default'] : newAttachProtocolTransport;

    const CONNECTION = Symbol("connection");
    function newEventHook(newConnection, detachConnection) {
        let attachments;
        let sessionIds;
        return [eventHook, getConnection, clearSessions];
        function eventHook(event, params) {
            if (params) {
                switch (event) {
                    case "Target.attachedToTarget":
                        attachedToTarget(params);
                        break;
                    case "Target.detachedFromTarget":
                        detachedFromTarget(params);
                        break;
                    case "Target.targetInfoChanged":
                        targetInfoChanged(params);
                        break;
                }
            }
        }
        function getSessionId(session, throwIfNotAttached = true) {
            let sessionId;
            if (typeof session === "string") {
                sessionId = session;
            }
            else if (sessionIds !== undefined &&
                session !== null &&
                typeof session === "object") {
                if ("sessionId" in session) {
                    sessionId = session.sessionId;
                }
                else if ("targetId" in session) {
                    const { targetId } = session;
                    sessionId = sessionIds.get(session.targetId);
                    if (!sessionId && throwIfNotAttached) {
                        throw new Error(`Target ${targetId} is not attached.`);
                    }
                }
            }
            return sessionId;
        }
        function getSession(session, throwIfNotAttached = true) {
            const sessionId = getSessionId(session, throwIfNotAttached);
            if (sessionId === undefined) {
                return;
            }
            if (attachments !== undefined) {
                const attachment = attachments.get(sessionId);
                if (attachment !== undefined) {
                    return attachment;
                }
            }
            if (throwIfNotAttached) {
                throw new Error(`Session ${sessionId} is no longer attached.`);
            }
        }
        function attachedToTarget({ sessionId, targetInfo, }) {
            const { targetId } = targetInfo;
            if (attachments === undefined) {
                attachments = new Map();
            }
            // we make the connection lazily
            attachments.set(sessionId, {
                [CONNECTION]: undefined,
                sessionId,
                targetId,
                targetInfo,
            });
            if (sessionIds === undefined) {
                sessionIds = new Map();
            }
            sessionIds.set(targetId, sessionId);
        }
        function detachedFromTarget({ sessionId, }) {
            if (attachments === undefined) {
                return;
            }
            const attachment = attachments.get(sessionId);
            if (attachment !== undefined) {
                attachments.delete(sessionId);
                if (sessionIds !== undefined) {
                    sessionIds.delete(attachment.targetId);
                }
                if (attachment[CONNECTION] !== undefined) {
                    attachment[CONNECTION] = undefined;
                    detachConnection(sessionId);
                }
            }
        }
        function targetInfoChanged({ targetInfo, }) {
            const attachment = getSession(targetInfo, false);
            if (attachment !== undefined) {
                attachment.targetInfo = targetInfo;
            }
        }
        function getConnection(session, throwIfNotAttached = true) {
            const attachment = getSession(session, throwIfNotAttached);
            if (attachment === undefined) {
                return;
            }
            let connection = attachment[CONNECTION];
            if (connection === undefined) {
                connection = newConnection(attachment);
                attachment[CONNECTION] = connection;
            }
            return connection;
        }
        function clearSessions() {
            if (attachments !== undefined) {
                for (const attachment of attachments.values()) {
                    if (attachment[CONNECTION] !== undefined) {
                        attachment[CONNECTION] = undefined;
                        detachConnection(attachment.sessionId);
                    }
                }
                attachments.clear();
            }
            if (sessionIds !== undefined) {
                sessionIds.clear();
            }
        }
    }

    /**
     * This method adapts a AttachProtocolTransport into higher level
     * ProtocolConnection.
     *
     * @param connect
     * @param newEventEmitter
     */
    function newRootConnection(attach, newEventEmitter) {
        return newProtocolConnection(attach, newEventEmitter);
    }
    function newSessionConnection(attachSession, newEventEmitter, session) {
        return newProtocolConnection(attachSession(session.sessionId), newEventEmitter, session);
    }
    function newProtocolConnection(attachTransport, newEventEmitter, session) {
        const emitter = newEventEmitter();
        let isDetached = false;
        const [onTargetAttached, onTargetDetached, send, raceDetached,] = attachTransport(onEvent, onError, onDetached);
        const [eventHook, connection, clearSessions] = newEventHook(newSessionConnection.bind(null, onTargetAttached, newEventEmitter), onTargetDetached);
        const base = {
            attachToTarget,
            connection,
            off: emitter.removeListener.bind(emitter),
            on: emitter.on.bind(emitter),
            once: emitter.once.bind(emitter),
            raceDetached,
            removeAllListeners: emitter.removeAllListeners.bind(emitter),
            removeListener: emitter.removeListener.bind(emitter),
            send,
            setAutoAttach,
            until,
            get isDetached() {
                return isDetached;
            },
        };
        if (session !== undefined) {
            return Object.create(base, {
                sessionId: {
                    get: () => session.sessionId,
                },
                targetId: {
                    get: () => session.targetId,
                },
                targetInfo: {
                    get: () => session.targetInfo,
                },
            });
        }
        return base;
        async function attachToTarget(targetId, raceCancellation) {
            if (typeof targetId === "object" && targetId !== null) {
                targetId = targetId.targetId;
            }
            const request = { flatten: true, targetId };
            const conn = connection(request, false);
            if (conn !== undefined) {
                return conn;
            }
            const resp = await send("Target.attachToTarget", request, raceCancellation);
            return connection(resp);
        }
        async function setAutoAttach(autoAttach, waitForDebuggerOnStart = false, raceCancellation) {
            const request = {
                autoAttach,
                flatten: true,
                waitForDebuggerOnStart,
            };
            await send("Target.setAutoAttach", request, raceCancellation);
        }
        function onEvent(event, params) {
            eventHook(event, params);
            emitter.emit(event, params);
        }
        function onError(error) {
            emitter.emit("error", error);
        }
        function onDetached() {
            if (isDetached) {
                return;
            }
            isDetached = true;
            // in practice it chrome notifies child sessions before
            // parent session but just in case we clear here
            clearSessions();
            emitter.emit("detached");
        }
        async function until(eventName, predicate, raceCancellation$1) {
            return raceCancellation.throwIfCancelled(await raceCancellation.disposablePromise((resolve, reject) => {
                const listener = predicate === undefined
                    ? resolve
                    : (event) => {
                        try {
                            if (predicate(event)) {
                                resolve(event);
                            }
                        }
                        catch (e) {
                            reject(e);
                        }
                    };
                emitter.on(eventName, listener);
                return () => {
                    emitter.removeListener(eventName, listener);
                };
            }, raceCancellation.combineRaceCancellation(raceDetached, raceCancellation$1)));
        }
    }

    /**
     * Creates a ProtocolConnection to the DevTools API from a MessageTransport.
     */
    function newProtocolConnection$1(attach, newEventEmitter, debug = () => void 0, raceCancellation) {
        return newRootConnection(newAttachProtocolTransport(attach, debug, raceCancellation), newEventEmitter);
    }

    exports.default = newProtocolConnection$1;
    exports.newProtocolConnection = newRootConnection;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
