"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stream_1 = require("stream");
const newBufferSplitter_1 = require("./newBufferSplitter");
const WS_URL_REGEX = /^(?:DevTools|Debugger) listening on (ws:\/\/\d+\.\d+\.\d+\.\d+:\d+\/.+$)/;
const PASSTHROUGH = {
    transform(chunk, _encoding, callback) {
        callback(undefined, chunk);
    },
    flush(callback) {
        callback();
    },
};
function newWebSocketUrlParser(onUrlParsed) {
    let state = createParsingState((url) => {
        onUrlParsed(url);
        state = PASSTHROUGH;
    });
    return new stream_1.Transform({
        transform(chunk, encoding, callback) {
            state.transform(chunk, encoding, callback);
        },
        flush(callback) {
            state.flush(callback);
        },
    });
}
exports.default = newWebSocketUrlParser;
function createParsingState(onUrlParsed) {
    const splitter = newBufferSplitter_1.default(10 /* LF */, (split) => {
        const url = findUrl(split);
        if (url !== undefined) {
            splitter.stop();
            onUrlParsed(url);
        }
    });
    return {
        transform(chunk, _encoding, callback) {
            splitter.push(chunk);
            callback(undefined, chunk);
        },
        flush(callback) {
            splitter.flush();
            callback();
        },
    };
}
function findUrl(split) {
    let length = split.byteLength;
    // check CR LF
    if (length > 0 && split[length - 1] === 13 /* CR */) {
        length--;
    }
    if (length === 0) {
        return;
    }
    const line = split.toString("utf8", 0, length);
    const match = WS_URL_REGEX.exec(line);
    if (match !== null) {
        const [, url] = match;
        return url;
    }
}
//# sourceMappingURL=newWebSocketUrlParser.js.map