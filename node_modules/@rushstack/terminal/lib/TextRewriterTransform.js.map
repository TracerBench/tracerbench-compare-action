{"version":3,"file":"TextRewriterTransform.js","sourceRoot":"","sources":["../src/TextRewriterTransform.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type { NewlineKind } from '@rushstack/node-core-library';\n\nimport { type ITerminalChunk, TerminalChunkKind } from './ITerminalChunk';\nimport { TerminalTransform, type ITerminalTransformOptions } from './TerminalTransform';\nimport type { TextRewriter, TextRewriterState } from './TextRewriter';\nimport { RemoveColorsTextRewriter } from './RemoveColorsTextRewriter';\nimport { NormalizeNewlinesTextRewriter } from './NormalizeNewlinesTextRewriter';\n\n/**\n * Constructor options for {@link TextRewriterTransform}.\n *\n * @public\n */\nexport interface ITextRewriterTransformOptions extends ITerminalTransformOptions {\n  /**\n   * A list of rewriters to be applied.  More items may be appended to the list, for example\n   * if {@link ITextRewriterTransformOptions.removeColors} is specified.\n   *\n   * @remarks\n   * The final list must contain at least one item.\n   */\n  textRewriters?: TextRewriter[];\n\n  /**\n   * If specified, a {@link RemoveColorsTextRewriter} will be appended to the list of rewriters.\n   */\n  removeColors?: boolean;\n\n  /**\n   * If `normalizeNewlines` or `ensureNewlineAtEnd` is specified, a {@link NormalizeNewlinesTextRewriter}\n   * will be appended to the list of rewriters with the specified settings.\n   *\n   * @remarks\n   * See {@link INormalizeNewlinesTextRewriterOptions} for details.\n   */\n  normalizeNewlines?: NewlineKind;\n\n  /**\n   * If `normalizeNewlines` or `ensureNewlineAtEnd` is specified, a {@link NormalizeNewlinesTextRewriter}\n   * will be appended to the list of rewriters with the specified settings.\n   *\n   * @remarks\n   * See {@link INormalizeNewlinesTextRewriterOptions} for details.\n   */\n  ensureNewlineAtEnd?: boolean;\n}\n\n/**\n * A {@link TerminalTransform} subclass that performs one or more {@link TextRewriter} operations.\n * The most common operations are {@link NormalizeNewlinesTextRewriter} and {@link RemoveColorsTextRewriter}.\n *\n * @remarks\n * The `TextRewriter` operations are applied separately to the `stderr` and `stdout` streams.\n * If multiple {@link ITextRewriterTransformOptions.textRewriters} are configured, they are applied\n * in the order that they appear in the array.\n *\n * @public\n */\nexport class TextRewriterTransform extends TerminalTransform {\n  private readonly _stderrStates: TextRewriterState[];\n  private readonly _stdoutStates: TextRewriterState[];\n\n  public readonly textRewriters: ReadonlyArray<TextRewriter>;\n\n  public constructor(options: ITextRewriterTransformOptions) {\n    super(options);\n\n    const textRewriters: TextRewriter[] = options.textRewriters || [];\n\n    if (options.removeColors) {\n      textRewriters.push(new RemoveColorsTextRewriter());\n    }\n    if (options.normalizeNewlines) {\n      textRewriters.push(\n        new NormalizeNewlinesTextRewriter({\n          newlineKind: options.normalizeNewlines,\n          ensureNewlineAtEnd: options.ensureNewlineAtEnd\n        })\n      );\n    }\n\n    if (textRewriters.length === 0) {\n      throw new Error('TextRewriterTransform requires at least one matcher');\n    }\n\n    this.textRewriters = textRewriters;\n\n    this._stderrStates = this.textRewriters.map((x) => x.initialize());\n    this._stdoutStates = this.textRewriters.map((x) => x.initialize());\n  }\n\n  protected onWriteChunk(chunk: ITerminalChunk): void {\n    if (chunk.kind === TerminalChunkKind.Stderr) {\n      this._processText(chunk, this._stderrStates);\n    } else if (chunk.kind === TerminalChunkKind.Stdout) {\n      this._processText(chunk, this._stdoutStates);\n    } else {\n      this.destination.writeChunk(chunk);\n    }\n  }\n\n  private _processText(chunk: ITerminalChunk, states: TextRewriterState[]): void {\n    let text: string = chunk.text;\n    for (let i: number = 0; i < states.length; ++i) {\n      if (text.length > 0) {\n        text = this.textRewriters[i].process(states[i], text);\n      }\n    }\n    if (text.length > 0) {\n      // If possible, avoid allocating a new chunk\n      if (text === chunk.text) {\n        this.destination.writeChunk(chunk);\n      } else {\n        this.destination.writeChunk({\n          text: text,\n          kind: chunk.kind\n        });\n      }\n    }\n  }\n\n  private _closeRewriters(states: TextRewriterState[], chunkKind: TerminalChunkKind): void {\n    let text: string = '';\n    for (let i: number = 0; i < states.length; ++i) {\n      if (text.length > 0) {\n        text = this.textRewriters[i].process(states[i], text);\n      }\n      text += this.textRewriters[i].close(states[i]);\n    }\n    if (text.length > 0) {\n      this.destination.writeChunk({\n        text: text,\n        kind: chunkKind\n      });\n    }\n  }\n\n  protected onClose(): void {\n    this._closeRewriters(this._stderrStates, TerminalChunkKind.Stderr);\n    this._closeRewriters(this._stdoutStates, TerminalChunkKind.Stdout);\n\n    this.autocloseDestination();\n  }\n}\n"]}