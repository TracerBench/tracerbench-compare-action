{"version":3,"file":"AstNamespaceExport.js","sourceRoot":"","sources":["../../src/analyzer/AstNamespaceExport.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAE3D,6DAA2F;AAI3F;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA4BG;AAEH,MAAa,kBAAmB,SAAQ,uCAAkB;IACxD,YAAmB,OAAmC;QACpD,KAAK,CAAC,OAAO,CAAC,CAAC;IACjB,CAAC;CACF;AAJD,gDAIC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { AstNamespaceImport, type IAstNamespaceImportOptions } from './AstNamespaceImport';\n\nexport interface IAstNamespaceExportOptions extends IAstNamespaceImportOptions {}\n\n/**\n * `AstNamespaceExport` represents a namespace that is created implicitly and exported by a statement\n * such as `export * as example from \"./file\";`\n *\n * @remarks\n *\n * A typical input looks like this:\n * ```ts\n * // Suppose that example.ts exports two functions f1() and f2().\n * export * as example from \"./file\";\n * ```\n *\n * API Extractor's .d.ts rollup will transform it into an explicit namespace, like this:\n * ```ts\n * declare f1(): void;\n * declare f2(): void;\n *\n * export declare namespace example {\n *   export {\n *     f1,\n *     f2\n *   }\n * }\n * ```\n *\n * The current implementation does not attempt to relocate f1()/f2() to be inside the `namespace`\n * because other type signatures may reference them directly (without using the namespace qualifier).\n * The AstNamespaceExports behaves the same as AstNamespaceImport, it just also has the inline export for the craeted namespace.\n */\n\nexport class AstNamespaceExport extends AstNamespaceImport {\n  public constructor(options: IAstNamespaceExportOptions) {\n    super(options);\n  }\n}\n"]}