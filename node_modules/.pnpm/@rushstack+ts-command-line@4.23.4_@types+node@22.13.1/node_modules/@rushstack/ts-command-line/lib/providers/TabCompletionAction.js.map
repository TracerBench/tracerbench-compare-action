{"version":3,"file":"TabCompletionAction.js","sourceRoot":"","sources":["../../src/providers/TabCompletionAction.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport stringArgv from 'string-argv';\n\nimport type { IRequiredCommandLineIntegerParameter } from '../parameters/CommandLineIntegerParameter';\nimport type { IRequiredCommandLineStringParameter } from '../parameters/CommandLineStringParameter';\nimport {\n  CommandLineParameterKind,\n  type CommandLineParameterBase,\n  CommandLineParameterWithArgument,\n  type CommandLineParameter\n} from '../parameters/BaseClasses';\nimport { CommandLineChoiceParameter } from '../parameters/CommandLineChoiceParameter';\nimport { CommandLineAction } from './CommandLineAction';\nimport { CommandLineConstants } from '../Constants';\n\nconst DEFAULT_WORD_TO_AUTOCOMPLETE: string = '';\nconst DEFAULT_POSITION: number = 0;\n\nexport class TabCompleteAction extends CommandLineAction {\n  private readonly _wordToCompleteParameter: IRequiredCommandLineStringParameter;\n  private readonly _positionParameter: IRequiredCommandLineIntegerParameter;\n  private readonly _actions: Map<string, Map<string, CommandLineParameter>>;\n  private readonly _globalParameters: Map<string, CommandLineParameter>;\n\n  public constructor(\n    actions: ReadonlyArray<CommandLineAction>,\n    globalParameters: ReadonlyArray<CommandLineParameterBase>\n  ) {\n    super({\n      actionName: CommandLineConstants.TabCompletionActionName,\n      summary: 'Provides tab completion.',\n      documentation: 'Provides tab completion.'\n    });\n\n    this._actions = new Map();\n    for (const action of actions) {\n      const parameterNameToParameterInfoMap: Map<string, CommandLineParameter> = new Map();\n      for (const parameter of action.parameters) {\n        parameterNameToParameterInfoMap.set(parameter.longName, parameter as CommandLineParameter);\n        if (parameter.shortName) {\n          parameterNameToParameterInfoMap.set(parameter.shortName, parameter as CommandLineParameter);\n        }\n      }\n      this._actions.set(action.actionName, parameterNameToParameterInfoMap);\n    }\n\n    this._globalParameters = new Map<string, CommandLineParameter>();\n    for (const parameter of globalParameters) {\n      this._globalParameters.set(parameter.longName, parameter as CommandLineParameter);\n      if (parameter.shortName) {\n        this._globalParameters.set(parameter.shortName, parameter as CommandLineParameter);\n      }\n    }\n\n    this._wordToCompleteParameter = this.defineStringParameter({\n      parameterLongName: '--word',\n      argumentName: 'WORD',\n      description: `The word to complete.`,\n      defaultValue: DEFAULT_WORD_TO_AUTOCOMPLETE\n    });\n\n    this._positionParameter = this.defineIntegerParameter({\n      parameterLongName: '--position',\n      argumentName: 'INDEX',\n      description: `The position in the word to be completed.`,\n      defaultValue: DEFAULT_POSITION\n    });\n  }\n\n  protected async onExecute(): Promise<void> {\n    const commandLine: string = this._wordToCompleteParameter.value;\n    const caretPosition: number = this._positionParameter.value || commandLine.length;\n\n    for await (const value of this.getCompletionsAsync(commandLine, caretPosition)) {\n      // eslint-disable-next-line no-console\n      console.log(value);\n    }\n  }\n\n  public async *getCompletionsAsync(\n    commandLine: string,\n    caretPosition: number = commandLine.length\n  ): AsyncIterable<string> {\n    const actions: Map<string, Map<string, CommandLineParameter>> = this._actions;\n\n    if (!commandLine || !caretPosition) {\n      yield* this._getAllActions();\n      return;\n    }\n\n    const tokens: string[] = Array.from(this.tokenizeCommandLine(commandLine));\n\n    // offset arguments by the number of global params in the input\n    const globalParameterOffset: number = this._getGlobalParameterOffset(tokens);\n\n    if (tokens.length < 2 + globalParameterOffset) {\n      yield* this._getAllActions();\n      return;\n    }\n\n    const lastToken: string = tokens[tokens.length - 1];\n    const secondLastToken: string = tokens[tokens.length - 2];\n\n    const lastCharacterIsWhitespace: boolean = !commandLine.slice(-1).trim();\n    const completePartialWord: boolean = caretPosition === commandLine.length && !lastCharacterIsWhitespace;\n\n    if (completePartialWord && tokens.length === 2 + globalParameterOffset) {\n      for (const actionName of actions.keys()) {\n        if (actionName.indexOf(tokens[1 + globalParameterOffset]) === 0) {\n          yield actionName;\n        }\n      }\n    } else {\n      for (const actionName of actions.keys()) {\n        if (actionName === tokens[1 + globalParameterOffset]) {\n          const parameterNameMap: Map<string, CommandLineParameter> = actions.get(actionName)!;\n\n          const parameterNames: string[] = Array.from(parameterNameMap.keys());\n\n          if (completePartialWord) {\n            for (const parameterName of parameterNames) {\n              if (parameterName === secondLastToken) {\n                const values: ReadonlySet<string> = await this._getParameterValueCompletionsAsync(\n                  parameterNameMap.get(parameterName)!\n                );\n                if (values.size > 0) {\n                  yield* this._completeParameterValues(values, lastToken);\n                  return;\n                }\n              }\n            }\n            yield* this._completeParameterValues(parameterNames, lastToken);\n          } else {\n            for (const parameterName of parameterNames) {\n              if (parameterName === lastToken) {\n                const values: ReadonlySet<string> = await this._getParameterValueCompletionsAsync(\n                  parameterNameMap.get(parameterName)!\n                );\n                if (values.size > 0) {\n                  yield* values;\n                  return;\n                }\n              }\n            }\n            for (const parameterName of parameterNames) {\n              if (\n                parameterName === lastToken &&\n                parameterNameMap.get(parameterName)!.kind !== CommandLineParameterKind.Flag\n              ) {\n                // The parameter is expecting a value, so don't suggest parameter names again\n                return;\n              }\n            }\n\n            yield* parameterNames;\n          }\n\n          break;\n        }\n      }\n    }\n  }\n\n  private *_getAllActions(): IterableIterator<string> {\n    yield* this._actions.keys();\n    yield* this._globalParameters.keys();\n  }\n\n  public tokenizeCommandLine(commandLine: string): string[] {\n    return stringArgv(commandLine);\n  }\n\n  private async _getParameterValueCompletionsAsync(\n    parameter: CommandLineParameter\n  ): Promise<ReadonlySet<string>> {\n    let choiceParameterValues: ReadonlySet<string> | undefined;\n    if (parameter.kind === CommandLineParameterKind.Choice) {\n      choiceParameterValues = parameter.alternatives;\n    } else if (parameter.kind !== CommandLineParameterKind.Flag) {\n      let parameterWithArgumentOrChoices:\n        | CommandLineParameterWithArgument\n        | CommandLineChoiceParameter\n        | undefined = undefined;\n      if (\n        parameter instanceof CommandLineParameterWithArgument ||\n        parameter instanceof CommandLineChoiceParameter\n      ) {\n        parameterWithArgumentOrChoices = parameter;\n      }\n\n      const completionValues: ReadonlyArray<string> | ReadonlySet<string> | undefined =\n        await parameterWithArgumentOrChoices?.completions?.();\n      choiceParameterValues = completionValues instanceof Set ? completionValues : new Set(completionValues);\n    }\n\n    return choiceParameterValues ?? new Set();\n  }\n\n  private _getGlobalParameterOffset(tokens: string[]): number {\n    const globalParameters: Map<string, CommandLineParameter> = this._globalParameters;\n    let count: number = 0;\n\n    outer: for (let i: number = 1; i < tokens.length; i++) {\n      for (const globalParameter of globalParameters.values()) {\n        if (tokens[i] !== globalParameter.longName && tokens[i] !== globalParameter.shortName) {\n          break outer;\n        }\n      }\n      count++;\n    }\n\n    return count;\n  }\n\n  private *_completeParameterValues(\n    choiceParameterValues: ReadonlyArray<string> | ReadonlySet<string>,\n    lastToken: string\n  ): IterableIterator<string> {\n    for (const choiceParameterValue of choiceParameterValues) {\n      if (choiceParameterValue.indexOf(lastToken) === 0) {\n        yield choiceParameterValue;\n      }\n    }\n  }\n}\n"]}