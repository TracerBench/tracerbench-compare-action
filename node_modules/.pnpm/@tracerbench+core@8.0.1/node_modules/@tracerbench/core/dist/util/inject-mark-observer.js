"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectLCPObserver = void 0;
const utils_1 = require("../trace/utils");
const is_navigation_timing_mark_1 = require("./is-navigation-timing-mark");
const LCP_EVENT_MSG = 'largest-contentful-paint event';
async function injectMarkObserver(page, mark, variable = '__tracerbench') {
    const scriptSource = (0, is_navigation_timing_mark_1.default)(mark)
        ? navigationObserver(variable)
        : markObserver(mark, variable);
    await page.send('Page.addScriptToEvaluateOnLoad', {
        scriptSource
    });
    return (raceCancelation) => waitForMarkOrLCP(page, variable, mark, raceCancelation);
}
exports.default = injectMarkObserver;
async function injectLCPObserver(page, priorMarker, variable = '__tracerbenchLCP') {
    const scriptSource = lcpObserver(variable, priorMarker);
    await page.send('Page.addScriptToEvaluateOnLoad', {
        scriptSource
    });
    return (raceCancelation) => waitForMarkOrLCP(page, variable, LCP_EVENT_MSG, raceCancelation);
}
exports.injectLCPObserver = injectLCPObserver;
function lcpObserver(variable, priorMarker) {
    return `"use strict";
    var __tracerbenchPriorMarkerObserved = (typeof ${priorMarker} === 'undefined')? true : false;
    if (!__tracerbenchPriorMarkerObserved){
      new PerformanceObserver((entryList, observer) => {
        if (!__tracerbenchPriorMarkerObserved) {
          var markerEntries = entryList.getEntriesByName(${priorMarker});
          if (markerEntries.length > 0) {
            __tracerbenchPriorMarkerObserved = true;
            observer.disconnect();
          }
        }
      }).observe({ type: 'mark' });
    }
    var ${variable} =
      self === top &&
      opener === null &&
      new Promise((resolve) =>
        new PerformanceObserver((entryList, observer) => {
          var lcpEntries = entryList.getEntriesByType('largest-contentful-paint');
          if (lcpEntries.length > 0 && __tracerbenchPriorMarkerObserved) {
            requestAnimationFrame(() => {
              resolve();
            });
          }
          observer.disconnect();
        }).observe({ type: 'largest-contentful-paint', buffered: true })
      );`;
}
function markObserver(mark, variable) {
    return `"use strict";
    var ${variable} =
      self === top &&
      opener === null &&
      new Promise((resolve) =>
        new PerformanceObserver((records, observer) => {
          if (records.getEntriesByName(${JSON.stringify(mark)}).length > 0) {
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                resolve();
              });
            });
            observer.disconnect();
          }
        }).observe({ type: 'mark' })
      );`;
}
function navigationObserver(variable) {
    return `"use strict";
  ${utils_1.enforcePaintEventFn}
var ${variable} =
  self === top &&
  opener === null &&
  new Promise((resolve) =>
    new PerformanceObserver((records, observer) => {
      if (records.getEntries().length > 0) {
        requestAnimationFrame(() => {
          enforcePaintEvent();
          requestIdleCallback(() => {
            resolve();
          });
        });
        observer.disconnect();
      }
    }).observe({ type: "navigation" })
  );`;
}
async function waitForMarkOrLCP(page, expression, waitType, raceCancelation) {
    let result;
    try {
        result = await page.send('Runtime.evaluate', {
            expression,
            awaitPromise: true,
            returnByValue: true
        }, raceCancelation);
        const { exceptionDetails } = result;
        if (exceptionDetails !== undefined) {
            throw waitForMarkOrEventError(waitType, { exceptionDetails });
        }
    }
    catch (original) {
        if (original instanceof Error) {
            throw waitForMarkOrEventError(waitType, { original });
        }
        else {
            throw original;
        }
    }
}
function waitForMarkOrEventError(target, { original, exceptionDetails }) {
    let message = `errored while waiting for ${target}`;
    if (exceptionDetails) {
        message += `: ${exceptionDetails.text}`;
    }
    if (original) {
        message += `: ${original.message}`;
    }
    const error = new Error(message);
    error.exceptionDetails = exceptionDetails;
    error.original = original;
    return error;
}
//# sourceMappingURL=inject-mark-observer.js.map