"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = require("fs-extra");
const race_cancellation_1 = require("race-cancellation");
const read_handle_1 = require("./read-handle");
async function runTrace(page, categories, raceCancellation, usingTracing, path) {
    const [completed, complete] = (0, race_cancellation_1.oneshot)();
    const raceEarlyComplete = (0, race_cancellation_1.newRaceCancellation)(completed, 'tracing completed earlier than expected');
    let stream;
    page.on('Tracing.tracingComplete', complete);
    try {
        await performTrace(page, {
            categories: categories.join(','),
            transferMode: 'ReturnAsStream'
        }, usingTracing, (0, race_cancellation_1.combineRaceCancellation)(raceEarlyComplete, raceCancellation));
        stream = await waitForTraceStream(completed, raceCancellation);
    }
    finally {
        page.off('Tracing.tracingComplete', complete);
    }
    return await readTraceStream(page, stream, raceCancellation, path);
}
exports.default = runTrace;
async function performTrace(conn, startRequest, usingTracing, raceCancellation) {
    await conn.send('Tracing.start', startRequest);
    try {
        await usingTracing(raceCancellation);
    }
    finally {
        await conn.send('Tracing.end');
    }
}
async function waitForTraceStream(completed, raceCancellation) {
    const { stream } = (0, race_cancellation_1.throwIfCancelled)(await raceCancellation(completed));
    if (stream === undefined) {
        throw new Error('trace missing stream handle');
    }
    return stream;
}
async function readTraceStream(conn, stream, raceCancellation, path) {
    const buffer = await (0, read_handle_1.default)(conn, stream, raceCancellation);
    if (path) {
        (0, fs_extra_1.writeFileSync)(path, buffer);
    }
    return JSON.parse(buffer.toString());
}
//# sourceMappingURL=run-trace.js.map