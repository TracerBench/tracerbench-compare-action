"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bounds_1 = require("../util/bounds");
const cache_1 = require("../util/cache");
const normalize_complete_events_1 = require("../util/normalize-complete-events");
const event_model_impl_1 = require("./event-model-impl");
const process_builder_1 = require("./process-builder");
const debug = require("debug");
const debugCallback = debug('tracerbench:model');
class TraceModelImpl {
    constructor({ start, end, events, metadata, processes }) {
        this.start = start;
        this.end = end;
        this.events = events;
        this.metadata = metadata || {};
        this.processes = Array.from(processes, (builder) => builder.build(this)).sort((a, b) => a.sortIndex - b.sortIndex);
    }
    get duration() {
        return this.end - this.start;
    }
    findRendererMain() {
        // we find the main renderer thread with the most events
        return this.processes
            .filter((p) => p.isRenderer)
            .map((p) => p.threads.find((t) => t.isRendererMain))
            .reduce((a, b) => b === undefined
            ? a
            : a === undefined
                ? b
                : b.events.length > a.events.length
                    ? b
                    : a);
    }
    toJSON() {
        return {
            traceEvents: this.events.map((event) => event.toJSON()),
            metadata: this.metadata
        };
    }
}
class ModelBuilder {
    constructor() {
        this.metadata = undefined;
        this.bounds = undefined;
        this.events = [];
        this.metadataEvents = [];
        this.processes = new cache_1.default((pid) => new process_builder_1.default(pid));
    }
    get start() {
        var _a, _b;
        return (_b = (_a = this.bounds) === null || _a === void 0 ? void 0 : _a.start) !== null && _b !== void 0 ? _b : 0;
    }
    get end() {
        var _a, _b;
        return (_b = (_a = this.bounds) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : 0;
    }
    process(pid) {
        return this.processes.get(pid);
    }
    extendBounds(event) {
        const { pid, start, end } = event;
        if (this.bounds === undefined) {
            this.bounds = new bounds_1.default(start, end);
        }
        else {
            this.bounds.extend(start, end);
        }
        if (pid) {
            this.process(pid).extendBounds(event);
        }
    }
    addMetadata(event) {
        const { pid } = event;
        this.metadataEvents.push(event);
        if (pid) {
            this.process(pid).addMetadata(event);
        }
    }
    addEvent(event) {
        const { pid } = event;
        if (pid) {
            this.process(pid).addEvent(event);
        }
    }
    build(trace) {
        let traceEvents;
        if (Array.isArray(trace)) {
            traceEvents = trace;
        }
        else {
            traceEvents = trace.traceEvents;
            this.metadata = trace.metadata;
        }
        let needsSort = false;
        let last = 0;
        const events = (this.events = new Array(traceEvents.length));
        debugCallback('creating models from %d trace events', traceEvents.length);
        for (let i = 0; i < traceEvents.length; i++) {
            const traceEvent = traceEvents[i];
            const { ts } = traceEvent;
            if (ts < last) {
                needsSort = true;
            }
            last = ts;
            const event = new event_model_impl_1.default(traceEvent, i);
            if (event.isMetadata()) {
                this.addMetadata(event);
            }
            else {
                this.extendBounds(event);
            }
            events[i] = event;
        }
        if (needsSort) {
            debugCallback('sorting models');
            events.sort((a, b) => {
                const cmp = a.start - b.start;
                return cmp !== 0 ? cmp : a.ord - b.ord;
            });
        }
        debugCallback('normalizing B/E events into X event');
        normalize_complete_events_1.default(events, this.start, this.end);
        // at this point we shouldn't have any non B or E models
        // and events are sorted
        debugCallback('adding events to processes and threads and setting parent of X events');
        for (const event of events) {
            this.addEvent(event);
        }
        debugCallback('finishing model');
        return new TraceModelImpl(this);
    }
}
exports.default = ModelBuilder;
//# sourceMappingURL=model-builder.js.map