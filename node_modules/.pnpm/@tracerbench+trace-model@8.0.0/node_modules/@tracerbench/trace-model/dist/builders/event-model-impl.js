"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const split_cat_1 = require("../util/split-cat");
const EMPTY_ARGS = Object.freeze({});
class EventModelImpl {
    constructor(traceEvent, ord) {
        const { args, ts: start } = traceEvent;
        this.ord = ord;
        this.pid = traceEvent.pid;
        this.tid = traceEvent.tid;
        this.ph = traceEvent.ph;
        this.cat = split_cat_1.default(traceEvent.cat);
        this.name = traceEvent.name;
        this.start = start;
        this.end =
            traceEvent.ph === "X" /* TRACE_EVENT_PHASE_COMPLETE */
                ? start + traceEvent.dur
                : start;
        this.args = args === "__stripped__" /* STRIPPED */ ? EMPTY_ARGS : args;
        this.traceEvent = traceEvent;
        this.parent = undefined;
    }
    get duration() {
        return this.end - this.start;
    }
    isBegin() {
        return this.ph === "B" /* TRACE_EVENT_PHASE_BEGIN */;
    }
    isEnd() {
        return this.ph === "E" /* TRACE_EVENT_PHASE_END */;
    }
    isComplete() {
        return this.ph === "X" /* TRACE_EVENT_PHASE_COMPLETE */;
    }
    isInstant() {
        return this.ph === "I" /* TRACE_EVENT_PHASE_INSTANT */;
    }
    isAsyncBegin() {
        return this.ph === "S" /* TRACE_EVENT_PHASE_ASYNC_BEGIN */;
    }
    isAsyncStepInto() {
        return this.ph === "T" /* TRACE_EVENT_PHASE_ASYNC_STEP_INTO */;
    }
    isAsyncStepPast() {
        return this.ph === "p" /* TRACE_EVENT_PHASE_ASYNC_STEP_PAST */;
    }
    isAsyncEnd() {
        return this.ph === "F" /* TRACE_EVENT_PHASE_ASYNC_END */;
    }
    isNestableAsyncBegin() {
        return this.ph === "b" /* TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN */;
    }
    isNestableAsyncEnd() {
        return this.ph === "e" /* TRACE_EVENT_PHASE_NESTABLE_ASYNC_END */;
    }
    isNestableAsyncInstant() {
        return this.ph === "n" /* TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT */;
    }
    isFlowBegin() {
        return this.ph === "s" /* TRACE_EVENT_PHASE_FLOW_BEGIN */;
    }
    isFlowStep() {
        return this.ph === "t" /* TRACE_EVENT_PHASE_FLOW_STEP */;
    }
    isFlowEnd() {
        return this.ph === "f" /* TRACE_EVENT_PHASE_FLOW_END */;
    }
    isMetadata() {
        return this.ph === "M" /* TRACE_EVENT_PHASE_METADATA */;
    }
    isCounter() {
        return this.ph === "C" /* TRACE_EVENT_PHASE_COUNTER */;
    }
    isSample() {
        return this.ph === "P" /* TRACE_EVENT_PHASE_SAMPLE */;
    }
    isCreateObject() {
        return this.ph === "N" /* TRACE_EVENT_PHASE_CREATE_OBJECT */;
    }
    isSnapshotObject() {
        return this.ph === "O" /* TRACE_EVENT_PHASE_SNAPSHOT_OBJECT */;
    }
    isDeleteObject() {
        return this.ph === "D" /* TRACE_EVENT_PHASE_DELETE_OBJECT */;
    }
    isMemoryDump() {
        return this.ph === "v" /* TRACE_EVENT_PHASE_MEMORY_DUMP */;
    }
    isMark() {
        return this.ph === "R" /* TRACE_EVENT_PHASE_MARK */;
    }
    isClockSync() {
        return this.ph === "c" /* TRACE_EVENT_PHASE_CLOCK_SYNC */;
    }
    isEnterContext() {
        return this.ph === "(" /* TRACE_EVENT_PHASE_ENTER_CONTEXT */;
    }
    isLeaveContext() {
        return this.ph === ")" /* TRACE_EVENT_PHASE_LEAVE_CONTEXT */;
    }
    getArg(name) {
        const value = this.args[name];
        if (value === "__stripped__" /* STRIPPED */)
            return;
        return value;
    }
    getStringArg(name, defaultValue) {
        const value = this.getArg(name);
        if (typeof value === 'string') {
            return value;
        }
        else {
            return defaultValue;
        }
    }
    getNumberArg(name, defaultValue) {
        const value = this.getArg(name);
        if (typeof value === 'number') {
            return value;
        }
        else {
            return defaultValue;
        }
    }
    hasCategory(category) {
        const cat = this.cat;
        if (typeof category === 'function') {
            return Array.isArray(cat) ? cat.some(category) : category(cat);
        }
        return Array.isArray(cat) ? cat.includes(category) : cat === category;
    }
    toJSON() {
        const { traceEvent } = this;
        if (Array.isArray(traceEvent)) {
            const [beginEvent, endEvent] = traceEvent;
            return Object.assign(Object.assign(Object.assign({}, endEvent), beginEvent), { ph: "X" /* TRACE_EVENT_PHASE_COMPLETE */, dur: endEvent.ts - beginEvent.ts, tdur: endEvent.tts === undefined || beginEvent.tts === undefined
                    ? undefined
                    : endEvent.tts - beginEvent.tts, tidelta: endEvent.ticount === undefined || beginEvent.ticount === undefined
                    ? undefined
                    : endEvent.ticount - beginEvent.ticount, args: this.args });
        }
        else {
            return traceEvent;
        }
    }
}
exports.default = EventModelImpl;
//# sourceMappingURL=event-model-impl.js.map