"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const merge_end_event_1 = require("./merge-end-event");
/**
 * Assumes events are already sorted
 */
function normalizeCompleteEvents(sortedEvents, start, end) {
    const begins = [];
    const ends = [];
    let pos = 0;
    for (let i = 0; i < sortedEvents.length; i++) {
        const event = sortedEvents[i];
        if (event.isEnd()) {
            const begin = findMatchingBegin(begins, event);
            if (begin === undefined) {
                ends.push(event);
            }
            else {
                merge_end_event_1.default(begin, event);
            }
            // filter end events
            continue;
        }
        if (event.isBegin()) {
            begins.push(event);
        }
        sortedEvents[pos++] = event;
    }
    sortedEvents.length = pos;
    if (begins.length > 0) {
        for (const begin of begins) {
            Object.assign(begin, {
                ph: "X" /* TRACE_EVENT_PHASE_COMPLETE */,
                end
            });
        }
    }
    if (ends.length > 0) {
        for (const end of ends) {
            Object.assign(end, {
                ph: "X" /* TRACE_EVENT_PHASE_COMPLETE */,
                start
            });
        }
        sortedEvents.unshift(...ends);
    }
}
exports.default = normalizeCompleteEvents;
function findMatchingBegin(begins, end) {
    for (let i = begins.length - 1; i >= 0; i--) {
        const begin = begins[i];
        if (begin.pid === end.pid && begin.tid === end.tid) {
            void begins.splice(i, 1);
            return begin;
        }
    }
}
//# sourceMappingURL=normalize-complete-events.js.map