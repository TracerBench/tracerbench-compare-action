"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const race_cancellation_1 = require("race-cancellation");
const execa_1 = require("./execa");
const newProcess_1 = require("./newProcess");
const newWebSocketUrlParser_1 = require("./newWebSocketUrlParser");
function newProcessWithWebSocketUrl(command, args, options, debugCallback) {
    const { stdio = "ignore", cwd, env, extendEnv } = options;
    const child = execa_1.default(command, args, {
        // disable buffer, pipe or drain
        buffer: false,
        stdio: [stdio, stdio, "pipe"],
        cwd,
        extendEnv,
        env,
    }, debugCallback);
    const process = newProcess_1.default(child, command, debugCallback);
    if (child.stderr === null) {
        throw new Error("missing stderr");
    }
    return Object.assign(process, {
        url: createUrl(child.stderr, stdio, process.raceExit),
    });
}
exports.default = newProcessWithWebSocketUrl;
function createUrl(stderr, stdio, raceExit) {
    let promise;
    return url;
    async function url(raceCancellation) {
        return race_cancellation_1.throwIfCancelled(await race_cancellation_1.combineRaceCancellation(raceExit, raceCancellation)(() => {
            if (promise === undefined) {
                promise = new Promise((resolve) => parseUrl(stderr, stdio, resolve));
            }
            return promise;
        }));
    }
}
function parseUrl(stderr, stdio, callback) {
    const parser = newWebSocketUrlParser_1.default(callback);
    stderr.pipe(parser);
    if (stdio === "inherit") {
        parser.pipe(process.stderr);
    }
    else if (stdio === "ignore") {
        parser.on("data", () => void 0);
    }
    else {
        throw new Error(`invalid stdio arg ${String(stdio)} expected ignore or inherit`);
    }
}
//# sourceMappingURL=newProcessWithWebSocketUrl.js.map