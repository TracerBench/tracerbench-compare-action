"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const execa_1 = require("./execa");
const newPipeMessageTransport_1 = require("./newPipeMessageTransport");
const newProcess_1 = require("./newProcess");
function newProcessWithPipeMessageTransport(command, args, options, debugCallback) {
    const { stdio = "ignore", cwd, env, extendEnv } = options;
    const child = execa_1.default(command, args, {
        // disable buffer, pipe or drain
        buffer: false,
        stdio: [stdio, stdio, stdio, "pipe", "pipe"],
        cwd,
        extendEnv,
        env,
    }, debugCallback);
    const process = newProcess_1.default(child, command, debugCallback);
    const [, , , writeStream, readStream] = child.stdio;
    const attach = newPipeMessageTransport_1.default((onRead, onReadEnd, onClose) => {
        void child.on("error", onClose);
        void child.on("exit", onClose);
        readStream.on("data", handleReadData);
        readStream.on("end", handleReadEnd);
        readStream.on("error", handleReadError);
        writeStream.on("close", handleWriteClose);
        writeStream.on("error", handleWriteError);
        return [(data) => writeStream.write(data), () => writeStream.end()];
        function handleReadData(buffer) {
            debugEvent("read", "data", buffer.byteLength);
            onRead(buffer);
        }
        function handleReadEnd() {
            debugEvent("read", "end");
            onReadEnd();
        }
        function handleReadError(error) {
            debugEvent("read", "error", error);
        }
        function handleWriteError(error) {
            debugEvent("write", "error", error);
            // writes while the other side is closing can cause EPIPE
            // just wait for close to actually happen and ignore it.
            if (error && "code" in error && error.code === "EPIPE") {
                return;
            }
            onClose(error);
        }
        function handleWriteClose() {
            debugEvent("write", "close");
            onClose();
        }
        function debugEvent(pipe, event, arg) {
            if (arg === undefined) {
                debugCallback("%s pipe (pid: %o) %o event", pipe, child.pid, event);
            }
            else {
                debugCallback("%s pipe (pid: %o) %o event: %O", pipe, child.pid, event, arg);
            }
        }
    });
    return Object.assign(process, { attach });
}
exports.default = newProcessWithPipeMessageTransport;
//# sourceMappingURL=newProcessWithPipeMessageTransport.js.map