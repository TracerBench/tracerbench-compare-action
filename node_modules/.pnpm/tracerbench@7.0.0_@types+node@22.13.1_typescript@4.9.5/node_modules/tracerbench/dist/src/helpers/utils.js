"use strict";
/* eslint-disable @typescript-eslint/explicit-function-return-type */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint:disable:no-console*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.sleep = exports.md5sum = exports.secondsToTime = exports.durationInSec = exports.timestamp = exports.logHeading = exports.chalkScheme = exports.toNearestHundreth = exports.convertToTypable = exports.parseMarkers = exports.convertMSToMicroseconds = exports.convertMicrosecondsToMS = exports.mergeLeft = exports.checkEnvironmentSpecificOverride = void 0;
const chalk = require("chalk");
const crypto_1 = require("crypto");
/**
 * Handles checking if there is a specific override for the attributeName in the tbConfigs for the given overrideObjectName.
 * Defaults to whatever is in the flags object if there is no override.
 *
 * @param attributeName - Attribute name to check if there is an override in overrideObjectName from tbConfig
 * @param flags - Object containing configs parsed from the Command class
 * @param overrideObjectName - Either "controlBenchmarkEnvironment" or "experimentBenchmarkEnvironment"
 * @param tbConfig - This refers to the parsed JSON from the config file if it exists
 */
// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
function checkEnvironmentSpecificOverride(attributeName, flags, overrideObjectName, tbConfig) {
    if (!tbConfig || !tbConfig[overrideObjectName]) {
        return flags[attributeName];
    }
    const environmentSpecificConfigs = tbConfig[overrideObjectName]; //eslint-disable-line @typescript-eslint/no-non-null-assertion
    if (!environmentSpecificConfigs[attributeName]) {
        return flags[attributeName];
    }
    return environmentSpecificConfigs[attributeName];
}
exports.checkEnvironmentSpecificOverride = checkEnvironmentSpecificOverride;
/**
 * Merge the contents of the right object into the left. Simply replace numbers, strings, arrays
 * and recursively call this function with objects.
 *
 * Note that typeof null == 'object'
 *
 * @param left - Destination object
 * @param right - Content of this object takes precedence
 */
function mergeLeft(left, right) {
    Object.keys(right).forEach((key) => {
        const leftValue = left[key];
        const rightValue = left[key];
        const matchingObjectType = typeof leftValue === "object" && typeof rightValue === "object";
        const isOneArray = Array.isArray(leftValue) || Array.isArray(rightValue);
        if (matchingObjectType && (left[key] || right[key]) && !isOneArray) {
            mergeLeft(left[key], right[key]);
        }
        else {
            left[key] = right[key];
        }
    });
    return left;
}
exports.mergeLeft = mergeLeft;
function convertMicrosecondsToMS(ms) {
    ms = typeof ms === "string" ? parseInt(ms, 10) : ms;
    return Math.floor(ms * 100) / 100000;
}
exports.convertMicrosecondsToMS = convertMicrosecondsToMS;
function convertMSToMicroseconds(ms) {
    ms = typeof ms === "string" ? parseInt(ms, 10) : ms;
    return Math.floor(ms * 1000);
}
exports.convertMSToMicroseconds = convertMSToMicroseconds;
function parseMarkers(m) {
    const a = [];
    if (typeof m === "string") {
        m = m.split(",");
    }
    for (let i = 1; i < m.length; i++) {
        a.push({
            start: m[i - 1],
            label: m[i],
        });
    }
    a.push({
        start: m[m.length - 1],
        label: "paint",
    });
    return a;
}
exports.parseMarkers = parseMarkers;
/**
 * "name" is expected to be a titlecased string. We want something the user can type easily so the passed string
 * is converted into lowercased words dasherized. Any extra "/" will also be removed.
 *
 * @param str - String to be converted to dasherized case
 */
function convertToTypable(name) {
    const split = name.split(" ");
    const lowercasedWords = split.map((word) => word.toLowerCase().replace(/\//g, ""));
    return lowercasedWords.join("-");
}
exports.convertToTypable = convertToTypable;
function toNearestHundreth(n) {
    return Math.round(n * 100) / 100;
}
exports.toNearestHundreth = toNearestHundreth;
exports.chalkScheme = {
    white: chalk.rgb(255, 255, 255),
    warning: chalk.rgb(255, 174, 66),
    header: chalk.rgb(255, 255, 255),
    regress: chalk.rgb(239, 100, 107),
    neutral: chalk.rgb(225, 225, 225),
    significant: chalk.rgb(0, 191, 255),
    imprv: chalk.rgb(135, 197, 113),
    phase: chalk.rgb(225, 225, 225),
    faint: chalk.rgb(80, 80, 80),
    checkmark: chalk.rgb(133, 153, 36)(`âœ”`),
    blackBgGreen: chalk.green.bgGreen,
    blackBgRed: chalk.rgb(239, 100, 107).bgRed,
    blackBgBlue: chalk.rgb(24, 132, 228).bgRgb(24, 132, 228),
    blackBgYellow: chalk.rgb(255, 174, 66).bgRgb(255, 174, 66),
    tbBranding: {
        lime: chalk.rgb(199, 241, 106),
        blue: chalk.rgb(24, 132, 228),
        aqua: chalk.rgb(56, 210, 211),
        dkBlue: chalk.rgb(10, 45, 70),
        grey: chalk.rgb(153, 153, 153),
    },
};
function logHeading(heading, headingType = "log") {
    switch (headingType) {
        case "log":
            console.log(`\n${exports.chalkScheme.blackBgBlue(`    ${exports.chalkScheme.white(heading)}    `)}\n`);
            break;
        case "warn":
            console.log(`\n${exports.chalkScheme.blackBgYellow(`    ${exports.chalkScheme.white("WARNING")}    `)} ${exports.chalkScheme.warning(heading)}\n`);
            break;
        case "alert":
            console.log(`\n${exports.chalkScheme.blackBgRed(`    ${exports.chalkScheme.white("! ALERT")}    `)} ${chalk.red(heading)}\n`);
            break;
    }
}
exports.logHeading = logHeading;
function timestamp() {
    return new Date().getTime();
}
exports.timestamp = timestamp;
function durationInSec(endTime, startTime) {
    return Math.round((endTime - startTime) / 1000);
}
exports.durationInSec = durationInSec;
function secondsToTime(sec) {
    const m = Math.floor((sec % 3600) / 60)
        .toString()
        .padStart(2, "0");
    const s = Math.floor(sec % 60)
        .toString()
        .padStart(2, "0");
    return `${m}m:${s}s`;
}
exports.secondsToTime = secondsToTime;
function md5sum(text) {
    return (0, crypto_1.createHash)("md5").update(text).digest("hex");
}
exports.md5sum = md5sum;
/**
 * Function to introduce a wait
 *
 * @param ms - How many milliseconds to wait
 */
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
exports.sleep = sleep;
//# sourceMappingURL=utils.js.map