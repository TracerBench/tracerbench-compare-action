"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@tracerbench/core");
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const command_config_1 = require("../../command-config");
const default_flag_args_1 = require("../../command-config/default-flag-args");
const flags_1 = require("../../helpers/flags");
class RecordHAR extends command_config_1.TBBaseCommand {
    async init() {
        const { flags } = this.parse(RecordHAR);
        this.parsedConfig = (0, command_config_1.getConfig)(flags.config, flags, this.explicitFlags);
    }
    async run() {
        const { flags } = this.parse(RecordHAR);
        const { url, dest, cookiespath, filename, marker, screenshots, proxy } = flags;
        const { network, cpuThrottleRate, headless, tbResultsFolder } = this.parsedConfig;
        // getConfig will always return defaultFlagArgs
        const resultsDir = tbResultsFolder;
        let { browserArgs } = this.parsedConfig;
        const conditions = {
            network: network ? network : "none",
            cpu: cpuThrottleRate ? parseInt(cpuThrottleRate, 10) : 0,
        };
        let cookies = [
            {
                name: "",
                value: "",
                domain: "",
                path: "",
            },
        ];
        // results folder
        (0, fs_extra_1.mkdirpSync)(resultsDir);
        // har dest folder (usecase when not identical)
        (0, fs_extra_1.mkdirpSync)(dest);
        if (cookiespath.length) {
            // grab the auth cookies
            cookies = await (0, fs_extra_1.readJson)((0, path_1.resolve)(cookiespath));
        }
        // if headless flag is true include the headless flags
        if (headless) {
            browserArgs = Array.isArray(browserArgs)
                ? browserArgs.concat(default_flag_args_1.headlessFlags)
                : default_flag_args_1.headlessFlags;
        }
        // if using a proxy server include the chrome switch with proxy url
        if (proxy) {
            const proxyServer = [`--proxy-server=https=${proxy}`];
            browserArgs = Array.isArray(browserArgs)
                ? browserArgs.concat(proxyServer)
                : proxyServer;
        }
        this.log(`Recording HAR ...`);
        // record the actual HAR and return the archive file
        const harArchiveResponse = await (0, core_1.recordHARClient)(url, cookies, marker, conditions, headless, browserArgs, screenshots);
        if (screenshots && harArchiveResponse.screenshotData) {
            harArchiveResponse.screenshotData.map((screenshot) => {
                const screenshotName = `record-har-${screenshot.name}-screenshot.png`;
                const screenshotPath = (0, path_1.resolve)((0, path_1.join)(resultsDir, screenshotName));
                (0, fs_extra_1.writeFileSync)(screenshotPath, screenshot.data, {
                    encoding: "base64",
                });
                this.log(`  ✔ ${screenshot.name} screenshot: ${screenshotPath}`);
            });
        }
        const harPath = (0, path_1.join)(dest, `${filename}.har`);
        // validate the har file can be parsed as JSON
        // validate that the expected URL matches what was recorded
        await this.validateHAR(harArchiveResponse.archive, url);
        (0, fs_extra_1.writeJsonSync)(harPath, harArchiveResponse.archive);
        this.log(`  ✔ HAR recorded: ${harPath}`);
    }
    async validateHAR(harJSON, url) {
        this.log(`Validating HAR ...`);
        try {
            const harFileURL = this.getURLfromHAR(harJSON);
            if (harFileURL !== url) {
                this.log(`  ! Expected: ${url}`);
                this.log(`  ! Actual: ${harFileURL}`);
                throw `The HAR was recorded with a different URL than expected. Expected and Actual should match.`;
            }
        }
        catch (error) {
            this.error(`  ✖ HAR file invalid. ${error}`);
        }
    }
    getURLfromHAR(harJSON) {
        try {
            const url = harJSON.log.entries[0].request.url;
            return url;
        }
        catch (error) {
            this.error(`\nCould not extract the URL from the HAR.\n${error}`);
        }
    }
}
exports.default = RecordHAR;
RecordHAR.description = "Generates a HAR file from a URL";
// eslint-disable-next-line @typescript-eslint/no-explicit-any
RecordHAR.flags = {
    url: (0, flags_1.url)({ required: true, default: undefined }),
    dest: (0, flags_1.dest)({ required: true }),
    cookiespath: (0, flags_1.cookiespath)({ required: true }),
    filename: (0, flags_1.filename)({ required: true, default: "tracerbench" }),
    marker: (0, flags_1.marker)({ required: true }),
    config: (0, flags_1.config)(),
    headless: flags_1.headless,
    screenshots: flags_1.screenshots,
    proxy: (0, flags_1.proxy)(),
    tbResultsFolder: (0, flags_1.tbResultsFolder)(),
};
//# sourceMappingURL=index.js.map