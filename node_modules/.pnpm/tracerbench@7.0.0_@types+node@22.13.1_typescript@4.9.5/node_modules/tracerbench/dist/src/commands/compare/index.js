"use strict";
/* eslint-disable @typescript-eslint/no-non-null-assertion */
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const core_1 = require("@tracerbench/core");
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const command_config_1 = require("../../command-config");
const default_flag_args_1 = require("../../command-config/default-flag-args");
const tb_config_1 = require("../../command-config/tb-config");
const device_settings_1 = require("../../helpers/device-settings");
const flags_1 = require("../../helpers/flags");
const utils_1 = require("../../helpers/utils");
const analyze_1 = require("./analyze");
const report_1 = require("./report");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const archiver = require("archiver");
class Compare extends command_config_1.TBBaseCommand {
    constructor(argv, config) {
        super(argv, config);
        this.parsedConfig = default_flag_args_1.defaultFlagArgs;
        this.analyzedJSONString = "";
        const { flags } = this.parse(Compare);
        this.explicitFlags = argv;
        this.compareFlags = flags;
    }
    // instantiated before this.run()
    async init() {
        const { flags } = this.parse(Compare);
        this.parsedConfig = (0, command_config_1.getConfig)(flags.config, flags, this.explicitFlags);
        this.compareFlags = flags;
        await this.parseFlags();
    }
    async run() {
        const { hideAnalysis } = this.compareFlags;
        const [controlSettings, experimentSettings] = this.generateControlExperimentServerConfig();
        // this should be directly above the instantiation of the InitialRenderBenchmarks
        if (this.parsedConfig.debug) {
            Object.entries(this.parsedConfig).forEach(([key, value]) => {
                if (value) {
                    this.log(`${key}: ${JSON.stringify(value)}`);
                }
            });
        }
        const benchmarks = {
            control: (0, core_1.createTraceNavigationBenchmark)(...controlSettings),
            experiment: (0, core_1.createTraceNavigationBenchmark)(...experimentSettings),
        };
        const sampleTimeout = this.parsedConfig.sampleTimeout;
        const startTime = (0, utils_1.timestamp)();
        const results = (await (0, core_1.run)([benchmarks.control, benchmarks.experiment], this.parsedConfig.fidelity, (elasped, completed, remaining, group, iteration) => {
            if (completed > 0) {
                const average = elasped / completed;
                const remainingSecs = Math.round((remaining * average) / 1000);
                const remainingTime = (0, utils_1.secondsToTime)(remainingSecs);
                console.log("%s: %s %s remaining", group.padStart(15), iteration.toString().padStart(2), `${remainingTime}`.padStart(10));
            }
            else {
                console.log("%s: %s", group.padStart(15), iteration.toString().padStart(2));
            }
        }, {
            sampleTimeoutMs: sampleTimeout && sampleTimeout * 1000,
        })).map(({ group, samples }) => {
            const meta = samples.length > 0 ? samples[0].metadata : {};
            return {
                group,
                set: group,
                samples,
                meta,
            };
        });
        const endTime = (0, utils_1.timestamp)();
        if (!results[0].samples[0]) {
            this.error(`Could not sample from provided urls\nCONTROL: ${this.parsedConfig.controlURL}\nEXPERIMENT: ${this.parsedConfig.experimentURL}.`);
        }
        const resultJSONPath = `${this.parsedConfig.tbResultsFolder}/compare.json`;
        (0, fs_extra_1.writeFileSync)(resultJSONPath, JSON.stringify(results));
        const tracesDir = `${this.parsedConfig.tbResultsFolder}/traces`;
        const zipOutput = (0, fs_extra_1.createWriteStream)(`${this.parsedConfig.tbResultsFolder}/traces.zip`);
        const archive = archiver("zip", {
            zlib: { level: 9 },
        });
        archive.directory(tracesDir, "traces");
        archive.pipe(zipOutput);
        archive.finalize();
        const duration = (0, utils_1.secondsToTime)((0, utils_1.durationInSec)(endTime, startTime));
        const message = `${utils_1.chalkScheme.blackBgGreen(`    ${utils_1.chalkScheme.white("SUCCESS")}    `)} ${this.parsedConfig.fidelity} test samples took ${duration}`;
        this.log(`\n${message}`);
        // if the stdout analysis is not hidden show it
        if (!hideAnalysis) {
            this.analyzedJSONString = await analyze_1.default.run([
                resultJSONPath,
                "--fidelity",
                `${this.parsedConfig.fidelity}`,
                "--regressionThreshold",
                `${this.parsedConfig.regressionThreshold}`,
                "--isCIEnv",
                `${this.parsedConfig.isCIEnv}`,
                `--regressionThresholdStat`,
                `${this.parsedConfig.regressionThresholdStat}`,
                `--jsonReport`,
            ]);
        }
        // if we want to run the CompareReport without calling a separate command
        if (this.parsedConfig.report) {
            await report_1.default.run([
                "--tbResultsFolder",
                `${this.parsedConfig.tbResultsFolder}`,
                "--config",
                `${this.parsedConfig.config}`,
                "--isCIEnv",
                `${this.parsedConfig.isCIEnv}`,
            ]);
        }
        // with debug flag output three files
        // on config specifics
        if (this.parsedConfig.debug) {
            (0, fs_extra_1.writeJSONSync)(`${this.parsedConfig.tbResultsFolder}/server-control-settings.json`, JSON.stringify(Object.assign(controlSettings), null, 2));
            (0, fs_extra_1.writeJSONSync)(`${this.parsedConfig.tbResultsFolder}/server-experiment-settings.json`, JSON.stringify(Object.assign(experimentSettings), null, 2));
            (0, fs_extra_1.writeJSONSync)(`${this.parsedConfig.tbResultsFolder}/compare-flags-settings.json`, JSON.stringify(Object.assign(this.parsedConfig), null, 2));
        }
        return this.analyzedJSONString;
    }
    async parseFlags() {
        const { tbResultsFolder, fidelity, markers, regressionThreshold, headless, controlURL, experimentURL, } = this.parsedConfig;
        // modifies properties of flags that were not set
        // during flag.parse(). these are intentionally
        // not deconstructed as to maintain the mutable
        // flags object state
        if (typeof fidelity === "string") {
            this.compareFlags.fidelity = parseInt(default_flag_args_1.fidelityLookup[fidelity], 10);
        }
        if (typeof markers === "string") {
            this.parsedConfig.markers = (0, utils_1.parseMarkers)(markers);
        }
        if (typeof regressionThreshold === "string") {
            this.parsedConfig.regressionThreshold = parseInt(regressionThreshold, 10);
        }
        if (typeof controlURL === undefined) {
            this.error("controlURL is required either in the tbconfig.json or as cli flag");
        }
        if (typeof experimentURL === undefined) {
            this.error("experimentURL is required either in the tbconfig.json or as cli flag");
        }
        // if headless flag is true include the headless flags
        if (headless) {
            this.parsedConfig.browserArgs =
                this.compareFlags.browserArgs.concat(default_flag_args_1.headlessFlags);
        }
        // if the folder for the tracerbench results file
        // does not exist then create it
        (0, fs_extra_1.mkdirpSync)((0, path_1.join)(tbResultsFolder, "traces"));
    }
    /**
     * Final result of the configs are in the following order:
     *
     * controlConfigs = tbconfig:controlBenchmarkEnvironment > command line > tbconfig > default
     * experimentConfigs = tbconfig:experimentBenchmarkEnvironment > command line > tbconfig > default
     *
     * This functions handles the tsconfig:** part since it is assumed that parent function that passed input "flags"
     * would've handled "command line > tbconfig > default"
     *
     * @param this.parsedConfig - Object containing configs parsed from the Command class
     */
    generateControlExperimentServerConfig() {
        const stdio = this.parsedConfig.debug ? "inherit" : "ignore";
        const controlBrowser = {
            stdio,
            additionalArguments: this.compareFlags.browserArgs,
        };
        const experimentBrowser = {
            stdio,
            additionalArguments: this.compareFlags.browserArgs,
        };
        // config for the browsers to leverage socks proxy
        if (this.parsedConfig.socksPorts) {
            if (controlBrowser.additionalArguments) {
                controlBrowser.additionalArguments =
                    controlBrowser.additionalArguments.concat([
                        `--proxy-server=socks5://0.0.0.0:${this.parsedConfig.socksPorts[0]}`,
                    ]);
            }
            if (experimentBrowser.additionalArguments) {
                experimentBrowser.additionalArguments =
                    experimentBrowser.additionalArguments.concat([
                        `--proxy-server=socks5://0.0.0.0:${this.parsedConfig.socksPorts[1]}`,
                    ]);
            }
        }
        const controlNetwork = (0, utils_1.checkEnvironmentSpecificOverride)("network", this.compareFlags, tb_config_1.CONTROL_ENV_OVERRIDE_ATTR, this.parsedConfig);
        const controlEmulateDevice = (0, utils_1.checkEnvironmentSpecificOverride)("emulateDevice", this.compareFlags, tb_config_1.CONTROL_ENV_OVERRIDE_ATTR, this.parsedConfig);
        const controlEmulateDeviceOrientation = (0, utils_1.checkEnvironmentSpecificOverride)("emulateDeviceOrientation", this.compareFlags, tb_config_1.CONTROL_ENV_OVERRIDE_ATTR, this.parsedConfig);
        const experimentNetwork = (0, utils_1.checkEnvironmentSpecificOverride)("network", this.compareFlags, tb_config_1.EXPERIMENT_ENV_OVERRIDE_ATTR, this.parsedConfig);
        const experimentEmulateDevice = (0, utils_1.checkEnvironmentSpecificOverride)("emulateDevice", this.compareFlags, tb_config_1.EXPERIMENT_ENV_OVERRIDE_ATTR, this.parsedConfig);
        const experimentEmulateDeviceOrientation = (0, utils_1.checkEnvironmentSpecificOverride)("emulateDeviceOrientation", this.compareFlags, tb_config_1.EXPERIMENT_ENV_OVERRIDE_ATTR, this.parsedConfig);
        const controlDeviceSettings = controlEmulateDevice
            ? (0, device_settings_1.getEmulateDeviceSettingForKeyAndOrientation)(controlEmulateDevice, controlEmulateDeviceOrientation)
            : {};
        const controlSettings = [
            "control",
            this.compareFlags.controlURL,
            this.compareFlags.markers,
            {
                spawnOptions: controlBrowser,
                pageSetupOptions: Object.assign(Object.assign({ cpuThrottlingRate: (0, utils_1.checkEnvironmentSpecificOverride)("cpuThrottleRate", this.compareFlags, tb_config_1.CONTROL_ENV_OVERRIDE_ATTR, this.parsedConfig) }, controlDeviceSettings), { emulateNetworkConditions: controlNetwork
                        ? core_1.networkConditions[controlNetwork]
                        : this.compareFlags.network }),
                traceOptions: {
                    captureV8RuntimeStats: this.compareFlags.runtimeStats,
                    saveTraceAs: (group, i) => `${this.compareFlags.tbResultsFolder}/traces/${group}${i}.json`,
                },
            },
        ];
        const experimentDeviceSettings = experimentEmulateDevice
            ? (0, device_settings_1.getEmulateDeviceSettingForKeyAndOrientation)(experimentEmulateDevice, experimentEmulateDeviceOrientation)
            : {};
        const experimentSettings = [
            "experiment",
            this.compareFlags.experimentURL,
            this.compareFlags.markers,
            {
                spawnOptions: experimentBrowser,
                pageSetupOptions: Object.assign(Object.assign({ cpuThrottlingRate: (0, utils_1.checkEnvironmentSpecificOverride)("cpuThrottleRate", this.compareFlags, tb_config_1.EXPERIMENT_ENV_OVERRIDE_ATTR, this.parsedConfig) }, experimentDeviceSettings), { emulateNetworkConditions: experimentNetwork
                        ? core_1.networkConditions[experimentNetwork]
                        : this.compareFlags.network }),
                traceOptions: {
                    captureV8RuntimeStats: this.compareFlags.runtimeStats,
                    saveTraceAs: (group, i) => `${this.compareFlags.tbResultsFolder}/traces/${group}${i}.json`,
                },
            },
        ];
        return [controlSettings, experimentSettings];
    }
}
exports.default = Compare;
Compare.description = "Compare the performance delta between an experiment and control";
Compare.flags = {
    hideAnalysis: command_1.flags.boolean({
        default: false,
        description: "Hide the the analysis output in terminal",
    }),
    browserArgs: (0, flags_1.browserArgs)({ required: true }),
    cpuThrottleRate: (0, flags_1.cpuThrottleRate)({ required: true }),
    fidelity: (0, flags_1.fidelity)({ required: true }),
    markers: (0, flags_1.markers)({ required: true }),
    network: (0, flags_1.network)({ required: true }),
    tbResultsFolder: (0, flags_1.tbResultsFolder)({ required: true }),
    controlURL: (0, flags_1.controlURL)({ required: false }),
    experimentURL: (0, flags_1.experimentURL)({ required: false }),
    emulateDevice: (0, flags_1.emulateDevice)(),
    emulateDeviceOrientation: (0, flags_1.emulateDeviceOrientation)(),
    socksPorts: (0, flags_1.socksPorts)(),
    regressionThreshold: (0, flags_1.regressionThreshold)(),
    sampleTimeout: (0, flags_1.sampleTimeout)(),
    config: (0, flags_1.config)(),
    runtimeStats: flags_1.runtimeStats,
    report: flags_1.report,
    debug: flags_1.debug,
    headless: flags_1.headless,
    isCIEnv: (0, flags_1.isCIEnv)(),
    regressionThresholdStat: flags_1.regressionThresholdStat,
};
//# sourceMappingURL=index.js.map