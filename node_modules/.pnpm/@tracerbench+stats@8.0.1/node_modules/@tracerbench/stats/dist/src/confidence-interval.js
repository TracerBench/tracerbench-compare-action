"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.confidenceInterval = exports.cartesianProduct = void 0;
const jStat = require("jstat");
const d3_array_1 = require("d3-array");
const utils_1 = require("./utils");
/**
 * Difference of x and y
 *
 * @private
 */
function _defaultModifier(x, y) {
    return x - y;
}
/**
 * Apply the passed "func" to the permutations of the items in listOne and listTwo
 *
 * @param listOne - Array of numbers
 * @param listTwo - Array of numbers
 * @param func - Function used to do something with x and y
 */
function cartesianProduct(listOne, listTwo, func = _defaultModifier) {
    let results = [];
    listOne.forEach((x) => {
        listTwo.forEach((y) => {
            results.push(func(x, y));
        });
    });
    results = results.sort((a, b) => a - b);
    return results;
}
exports.cartesianProduct = cartesianProduct;
/**
 * Calculate the confidence interval of the delta between the two distributions
 *
 * @param distributionOne - Expected to be array of numbers
 * @param distributionTwo - Expected to be array of numbers
 * @param interval - Float between 0 and 1
 */
function confidenceInterval(a, b, confidence) {
    var _a;
    const aLength = a.length;
    const bLength = b.length;
    const maxU = aLength * bLength;
    const meanU = maxU / 2;
    // subtract every control data point to every experiment data point
    const deltas = a
        .map((a) => b.map((b) => a - b))
        .flat()
        .sort((a, b) => a - b);
    // count the number of "wins" a > b and 0.5 for a tie if a == b
    const U = deltas.reduce((accum, value) => accum + (value < 0 ? 1 : value == 0 ? 0.5 : 0), 0);
    const lowerTail = U <= meanU;
    const standardDeviationU = Math.sqrt((maxU * (aLength + bLength + 1)) / 12);
    // we are estimating a discrete distribution so bias the mean depending on which tail
    // we are computing the pValue for. literally just +/- 0.5
    const continuityCorrection = lowerTail ? 0.5 : -0.5;
    // how many standard deviations the result is given the null hypothesis is true
    const zScore = (U - meanU + continuityCorrection) / standardDeviationU;
    // z is symmetrical, so use lower tail and double the cumulative of U for each tail
    // since this is a two tailed test. normal cumulative distribution function
    const pValue = jStat.normal.cdf(-Math.abs(zScore), 0, 1) * 2;
    const alpha = 1 - confidence;
    const lowerU = Math.round(jStat.normal.inv(alpha / 2, meanU + 0.5, standardDeviationU));
    const upperU = Math.round(jStat.normal.inv(1 - alpha / 2, meanU + 0.5, standardDeviationU));
    // set percentage delta from control median
    const aMedian = d3_array_1.median(a);
    const medianDeltas = d3_array_1.median(deltas);
    return {
        min: deltas[lowerU],
        median: medianDeltas !== null && medianDeltas !== void 0 ? medianDeltas : 0,
        max: deltas[upperU],
        zScore: +zScore.toPrecision(4),
        pValue: +pValue.toPrecision(4),
        U,
        asPercent: {
            percentMin: utils_1.toNearestHundreth((deltas[lowerU] / aMedian) * 100),
            percentMedian: (_a = utils_1.toNearestHundreth((medianDeltas / aMedian) * 100)) !== null && _a !== void 0 ? _a : 0,
            percentMax: utils_1.toNearestHundreth((deltas[upperU] / aMedian) * 100)
        }
    };
}
exports.confidenceInterval = confidenceInterval;
//# sourceMappingURL=confidence-interval.js.map