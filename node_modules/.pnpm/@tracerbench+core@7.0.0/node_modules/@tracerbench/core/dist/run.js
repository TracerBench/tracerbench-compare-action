"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const race_cancellation_1 = require("race-cancellation");
const gc_1 = require("./util/gc");
const SETUP_TIMEOUT = 5000;
const SAMPLE_TIMEOUT = 30 * 1000;
async function run(benchmarks, iterations, progress, options = {}) {
    checkUniqueNames(benchmarks);
    const samplers = {};
    const { setupTimeoutMs = SETUP_TIMEOUT, sampleTimeoutMs = SAMPLE_TIMEOUT, raceCancellation } = options;
    let sampleGroups;
    try {
        await setupSamplers(benchmarks, samplers, setupTimeoutMs, raceCancellation);
        sampleGroups = await takeSamples(samplers, iterations, progress, sampleTimeoutMs, raceCancellation);
    }
    finally {
        await disposeSamplers(samplers);
    }
    return sampleGroups;
}
exports.default = run;
async function takeSamples(samplers, samplesPerGroup, progress, sampleTimeoutMs, raceCancellation) {
    const groups = Object.keys(samplers);
    const sampleCount = (samplesPerGroup + 1) * groups.length;
    const sampleGroups = [];
    const groupedSamples = {};
    const start = Date.now();
    let completed = 0;
    // we take 1 extra iteration we don't keep
    for (let i = 0; i <= samplesPerGroup; i++) {
        // don't bother shuffling throw away iteration
        if (i > 0) {
            shuffle(groups);
        }
        for (const group of groups) {
            progress(Date.now() - start, completed, sampleCount - completed, group, i);
            (0, gc_1.default)();
            const sampler = samplers[group];
            const sample = await sampleWithTimeout(sampler, i, i === 0, sampleTimeoutMs, raceCancellation);
            if (i === 0) {
                const samples = new Array(samplesPerGroup);
                groupedSamples[group] = samples;
                sampleGroups.push({ group, samples });
            }
            else {
                groupedSamples[group][i - 1] = sample;
            }
            completed++;
        }
    }
    return sampleGroups;
}
async function setupWithTimeout(benchmark, setupTimeoutMs, raceCancellation) {
    const sampler = await (0, race_cancellation_1.withRaceTimeout)((raceTimeout) => benchmark.setup(raceTimeout), setupTimeoutMs)(raceCancellation);
    return (0, race_cancellation_1.throwIfCancelled)(sampler);
}
async function sampleWithTimeout(sampler, iteration, isTrial, sampleTimeoutMs, raceCancellation) {
    const sample = await (0, race_cancellation_1.withRaceTimeout)((raceTimeout) => sampler.sample(iteration, isTrial, raceTimeout), sampleTimeoutMs)(raceCancellation);
    return (0, race_cancellation_1.throwIfCancelled)(sample);
}
async function setupSamplers(benchmarks, samplers, setupTimeoutMs, raceCancellation) {
    void (await Promise.all(benchmarks.map(async (benchmark) => {
        const sampler = await setupWithTimeout(benchmark, setupTimeoutMs, raceCancellation);
        samplers[benchmark.group] = sampler;
    })));
}
async function disposeSamplers(samplers) {
    void (await Promise.all(Object.keys(samplers).map((group) => samplers[group].dispose())));
}
function shuffle(arr) {
    // for i from n−1 downto 1 do
    //      j ← random integer such that 0 ≤ j ≤ i
    //      exchange a[j] and a[i]
    for (let i = arr.length - 1; i >= 1; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = arr[j];
        arr[j] = arr[i];
        arr[i] = tmp;
    }
}
function checkUniqueNames(benchmarks) {
    const set = new Set();
    for (const benchmark of benchmarks) {
        if (set.has(benchmark.group)) {
            throw new Error(`duplicate benchmark group name ${benchmark.group}`);
        }
    }
}
//# sourceMappingURL=run.js.map