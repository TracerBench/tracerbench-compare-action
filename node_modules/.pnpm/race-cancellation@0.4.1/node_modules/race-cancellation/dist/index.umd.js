(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.RaceCancellation = {}));
}(this, function (exports) { 'use strict';

    /**
     * A symbol that brands a Cancellation.
     *
     * This symbol is a runtime registered symbol so that if multiple
     * versions of the module are loaded it interops.
     *
     * So that for an unknown x
     * `typeof x === "object" && x !== null && Symbol.for("isCancellation") in x`
     */
    const cancellationBrand = Symbol.for("isCancellation");

    function newCancellation(kind = "Cancellation" /* Cancellation */, message = "the task was cancelled") {
        return {
            [cancellationBrand]: true,
            kind,
            message,
        };
    }

    const thunkBrand = Symbol("thunkResult");
    const hasCompleted = Symbol("hasCompleted");

    function isCancellation(result, kind) {
        return (typeof result === "object" &&
            result !== null &&
            cancellationBrand in result &&
            (kind === undefined || kind === result.kind));
    }

    function once(force) {
        let unforced = true;
        let result;
        const thunk = (() => {
            if (unforced) {
                result = force();
                unforced = false;
            }
            return result;
        });
        thunk[thunkBrand] = true;
        return thunk;
    }

    /**
     * Creates a tuple of a function to lazily build a promise of a one time event
     * and a method to complete the promise.
     */
    function oneshot() {
        let result;
        let onResolve;
        const thunk = once(() => thunk[hasCompleted]
            ? Promise.resolve(result)
            : new Promise(resolve => {
                onResolve = resolve;
            }));
        thunk[thunkBrand] = true;
        thunk[hasCompleted] = false;
        const complete = value => {
            if (thunk[hasCompleted]) {
                return;
            }
            thunk[hasCompleted] = true;
            result = value;
            if (onResolve !== undefined) {
                onResolve(value);
            }
        };
        return [thunk, complete];
    }
    function isOneshot(task) {
        return thunkBrand in task && hasCompleted in task;
    }
    function intoOneshot(task) {
        if (isOneshot(task)) {
            return task;
        }
        const thunk = once(async () => {
            try {
                return await task();
            }
            finally {
                thunk[hasCompleted] = true;
            }
        });
        thunk[hasCompleted] = false;
        return thunk;
    }

    /**
     * Create a race cancellation function.
     *
     * @param cancellation lazily builds the cancellation promise chain.
     * @param newCancellation a function that creates the cancellation result.
     */
    function newRaceCancellation(cancellation, cancellationMessage, cancellationKind) {
        const cancellationOneshot = intoOneshot(cancellation);
        const intoCancellation = newIntoCancellation(cancellationMessage, cancellationKind);
        return task => raceCancellation(cancellationOneshot, task, intoCancellation);
    }
    function raceCancellation(cancellation, task, intoCancellation) {
        return typeof task === "function"
            ? cancellation[hasCompleted]
                ? cancellation().then(intoCancellation)
                : Promise.race([task(), cancellation().then(intoCancellation)])
            : Promise.race([task, cancellation().then(intoCancellation)]);
    }
    function newIntoCancellation(cancellationMessage, cancellationKind) {
        return function intoCancellation(result) {
            if (isCancellation(result)) {
                return result;
            }
            return newCancellation(cancellationKind, cancellationMessage);
        };
    }

    /**
     * Returns a tuple of a `RaceCancellation` with a cancel function that cancels it.
     */
    function cancellableRace() {
        const [cancellation, cancel] = oneshot();
        const raceCancellation = newRaceCancellation(cancellation);
        return [
            raceCancellation,
            (message, name) => cancel(newCancellation(name, message)),
        ];
    }

    /**
     * Allows an async function to add raceCancellation as an optional param
     * in a backwards compatible way by using this as the default.
     */
    const noopRaceCancellation = (task) => typeof task === "function"
        ? Promise.resolve().then(task)
        : Promise.resolve(task);

    /**
     * Returns a RaceCancellation that is the combination of two RaceCancellation implemenations.
     *
     * For convenience of writing methods that take cancellations, the params
     * are optional. If a is undefined, then b is retuned, if b is undefined then a
     * is returned, and if they both are undefined a noop race that just invokes
     * the task is returned.
     */
    function combineRaceCancellation(a, b) {
        return a === undefined
            ? b === undefined
                ? noopRaceCancellation
                : b
            : b === undefined
                ? a
                : task => a(() => b(task));
    }

    async function disposablePromise(executor, raceCancellation = noopRaceCancellation) {
        let dispose;
        try {
            return await raceCancellation(() => new Promise((resolve, reject) => {
                dispose = executor(resolve, reject);
            }));
        }
        finally {
            if (dispose !== undefined) {
                dispose();
            }
        }
    }

    /**
     * Default CreateTimeout implementation using setTimeout/clearTimeout, allows
     */
    const newTimeoutDefault = (() => {
        /* istanbul ignore if */
        if (typeof setTimeout !== "function") {
            // setTimeout is not actually part of the script host definition
            // but the expectation is that if you are running on a host that
            // doesn't have setTimeout defined is that you do not rely on the
            // default
            return undefined;
        }
        function newTimeout(callback, miliseconds) {
            const id = setTimeout(callback, miliseconds);
            return () => clearTimeout(id);
        }
        return newTimeout;
    })();

    /**
     * Cancellable promise of a timeout.
     *
     * If the cancellation wins the race the timeout will cleanup
     * (allowing node to exit for example).
     *
     * ```js
     * await sleep(1000, raceCancellation);
     * ```
     *
     * @param milliseconds timeout in milliseconds
     * @param raceCancellation a function to race the timeout promise against a
     *                         cancellation.
     * @param newTimeout defaults to setTimeout/clearTimeout
     *                   allows you to provide other implementation for testing
     */
    async function sleep(milliseconds, raceCancellation = noopRaceCancellation, newTimeout = newTimeoutDefault) {
        return disposablePromise(resolve => newTimeout(resolve, milliseconds), raceCancellation);
    }

    /**
     * Throw if the `result` is a `Cancellation` otherwise return it.
     * @param result the result of a cancellable task.
     */
    function throwIfCancelled(result) {
        if (isCancellation(result)) {
            const error = new Error(result.message);
            error.name = `${result.kind}Error`;
            error.kind = result.kind;
            error[cancellationBrand] = true;
            throw error;
        }
        return result;
    }

    /**
     * Wrap a cancellable task combining its input `RaceCancellation` with a race against the task
     * being settled, so that if any cancellable sub-tasks are combined with `Promise.all`
     * or `Promise.race` they will be cancelled if their branch was short circuited by
     * another branch rejecting in a `Promise.all` or their branch lost to another branch in a
     * `Promise.race`.
     *
     * @param task a cancellable task
     * @returns an optionally cancellable task
     */
    function withRaceSettled(task) {
        const [raceWinner, cancelLosers] = cancellableRace();
        return async (raceCancellation) => {
            try {
                const combined = combineRaceCancellation(raceCancellation, raceWinner);
                return await task(combined);
            }
            finally {
                cancelLosers("the task was short-circuited by another concurrent task winning a Promise.race or rejecting a Promise.all", "ShortCircuit" /* ShortCircuit */);
            }
        };
    }

    /**
     * Wrap a cancellable task to pass in a raceCancellation that combines the input raceCancellation
     * with a race against a cancellable cancellation task.
     *
     * ```js
     * async function fetchWithTimeout(url, timeoutMs, outerRaceCancellation) {
     *   const timeoutTask = raceCancellation => cancellableTimeout(timeoutMs, raceCancellation);
     *   const task = raceCancellation => cancellableFetch(url, raceCancellation);
     *   const taskWithTimeout = withRaceCancellableTask(
     *     task,
     *     timeoutTask,
     *     () => newTimeoutCancellation(`fetch did not resolve within ${timeoutMs}`),
     *   );
     *   return await taskWithTimeout(outerRaceCancellation);
     * }
     * ```
     *
     * @param task a cancellable task
     * @param cancellationTask a cancellable cancellation task, either resolves as void
     *                         or it resolves in a `Cancellation`, if void, it will default
     *                         the creating the default `Cancellation` or the provided
     *                         `newCancellation` argument.
     * @param newCancellation optional function for creating a `Cancellation`
     */
    function withRaceCancellationTask(task, cancellationTask, cancellationMessage, cancellationKind) {
        return withRaceSettled((raceCancellation) => task(
        // combination allows the outer cancellation to avoid starting the task
        // if it is already cancelled since cancellationTask will always start
        // the raced task because it doesn't have a way to peek the completion
        combineRaceCancellation(raceCancellation, newRaceCancellation(() => cancellationTask(raceCancellation), cancellationMessage, cancellationKind))));
    }

    /**
     * Wrap a cancellable task with a timeout.
     *
     * ```js
     * async function fetchWithTimeout(url, timeoutMs, raceCancellation) {
     *   return await withRaceTimeout(raceTimeout => {
     *      return await cancellableFetch(url, raceTimeout));
     *   }, timeoutMs)(raceCancellation);
     * }
     * ```
     *
     * @param task a cancellable task
     * @param milliseconds timeout in miliseconds
     * @param message optional cancellation message
     * @param newTimeout optional implementation of timeout creation for testing
     */
    function withRaceTimeout(task, milliseconds, message, newTimeout) {
        return withRaceCancellationTask(task, raceCancellation => sleep(milliseconds, raceCancellation, newTimeout), message || `task took longer than ${milliseconds}ms`, "Timeout" /* Timeout */);
    }

    exports.cancellableRace = cancellableRace;
    exports.cancellationBrand = cancellationBrand;
    exports.combineRaceCancellation = combineRaceCancellation;
    exports.disposablePromise = disposablePromise;
    exports.isCancellation = isCancellation;
    exports.newCancellation = newCancellation;
    exports.newRaceCancellation = newRaceCancellation;
    exports.noopRaceCancellation = noopRaceCancellation;
    exports.oneshot = oneshot;
    exports.sleep = sleep;
    exports.throwIfCancelled = throwIfCancelled;
    exports.withRaceCancellationTask = withRaceCancellationTask;
    exports.withRaceSettled = withRaceSettled;
    exports.withRaceTimeout = withRaceTimeout;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=index.umd.js.map
