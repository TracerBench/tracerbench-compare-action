{"version":3,"file":"FileError.js","sourceRoot":"","sources":["../src/FileError.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { type FileLocationStyle, Path } from './Path';\nimport { TypeUuid } from './TypeUuid';\n\n/**\n * Provides options for the creation of a FileError.\n *\n * @public\n */\nexport interface IFileErrorOptions {\n  /**\n   * The absolute path to the file that contains the error.\n   */\n  absolutePath: string;\n\n  /**\n   * The root folder for the project that the error is in relation to.\n   */\n  projectFolder: string;\n\n  /**\n   * The line number of the error in the target file. Minimum value is 1.\n   */\n  line?: number;\n\n  /**\n   * The column number of the error in the target file. Minimum value is 1.\n   */\n  column?: number;\n}\n\n/**\n * Provides options for the output message of a file error.\n *\n * @public\n */\nexport interface IFileErrorFormattingOptions {\n  /**\n   * The format for the error message. If no format is provided, format 'Unix' is used by default.\n   */\n  format?: FileLocationStyle;\n}\n\nconst uuidFileError: string = '37a4c772-2dc8-4c66-89ae-262f8cc1f0c1';\n\nconst baseFolderEnvVar: string = 'RUSHSTACK_FILE_ERROR_BASE_FOLDER';\n\n/**\n * An `Error` subclass that should be thrown to report an unexpected state that specifically references\n * a location in a file.\n *\n * @remarks The file path provided to the FileError constructor is expected to exist on disk. FileError\n * should not be used for reporting errors that are not in reference to an existing file.\n *\n * @public\n */\nexport class FileError extends Error {\n  /** @internal */\n  public static _sanitizedEnvironmentVariable: string | undefined;\n  /** @internal */\n  public static _environmentVariableIsAbsolutePath: boolean = false;\n\n  private static _environmentVariableBasePathFnMap: ReadonlyMap<\n    string | undefined,\n    (fileError: FileError) => string | undefined\n  > = new Map([\n    [undefined, (fileError: FileError) => fileError.projectFolder],\n    ['{PROJECT_FOLDER}', (fileError: FileError) => fileError.projectFolder],\n    ['{ABSOLUTE_PATH}', (fileError: FileError) => undefined as string | undefined]\n  ]);\n\n  /** {@inheritdoc IFileErrorOptions.absolutePath} */\n  public readonly absolutePath: string;\n  /** {@inheritdoc IFileErrorOptions.projectFolder} */\n  public readonly projectFolder: string;\n  /** {@inheritdoc IFileErrorOptions.line} */\n  public readonly line: number | undefined;\n  /** {@inheritdoc IFileErrorOptions.column} */\n  public readonly column: number | undefined;\n\n  /**\n   * Constructs a new instance of the {@link FileError} class.\n   *\n   * @param message - A message describing the error.\n   * @param options - Options for the error.\n   */\n  public constructor(message: string, options: IFileErrorOptions) {\n    super(message);\n\n    this.absolutePath = options.absolutePath;\n    this.projectFolder = options.projectFolder;\n    this.line = options.line;\n    this.column = options.column;\n\n    // Manually set the prototype, as we can no longer extend built-in classes like Error, Array, Map, etc.\n    // https://github.com/microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    //\n    // Note: the prototype must also be set on any classes which extend this one\n    (this as any).__proto__ = FileError.prototype; // eslint-disable-line @typescript-eslint/no-explicit-any\n  }\n\n  /**\n   * Get the Unix-formatted the error message.\n   *\n   * @override\n   */\n  public toString(): string {\n    // Default to formatting in 'Unix' format, for consistency.\n    return this.getFormattedErrorMessage();\n  }\n\n  /**\n   * Get the formatted error message.\n   *\n   * @param options - Options for the error message format.\n   */\n  public getFormattedErrorMessage(options?: IFileErrorFormattingOptions): string {\n    return Path.formatFileLocation({\n      format: options?.format || 'Unix',\n      baseFolder: this._evaluateBaseFolder(),\n      pathToFormat: this.absolutePath,\n      message: this.message,\n      line: this.line,\n      column: this.column\n    });\n  }\n\n  private _evaluateBaseFolder(): string | undefined {\n    // Cache the sanitized environment variable. This means that we don't support changing\n    // the environment variable mid-execution. This is a reasonable tradeoff for the benefit\n    // of being able to cache absolute paths, since that is only able to be determined after\n    // running the regex, which is expensive. Since this would be a common execution path for\n    // tools like Rush, we should optimize for that.\n    if (!FileError._sanitizedEnvironmentVariable && process.env[baseFolderEnvVar]) {\n      // Strip leading and trailing quotes, if present.\n      FileError._sanitizedEnvironmentVariable = process.env[baseFolderEnvVar]!.replace(/^(\"|')|(\"|')$/g, '');\n    }\n\n    if (FileError._environmentVariableIsAbsolutePath) {\n      return FileError._sanitizedEnvironmentVariable;\n    }\n\n    // undefined environment variable has a mapping to the project folder\n    const baseFolderFn: ((fileError: FileError) => string | undefined) | undefined =\n      FileError._environmentVariableBasePathFnMap.get(FileError._sanitizedEnvironmentVariable);\n    if (baseFolderFn) {\n      return baseFolderFn(this);\n    }\n\n    const baseFolderTokenRegex: RegExp = /{([^}]+)}/g;\n    const result: RegExpExecArray | null = baseFolderTokenRegex.exec(\n      FileError._sanitizedEnvironmentVariable!\n    );\n    if (!result) {\n      // No tokens, assume absolute path\n      FileError._environmentVariableIsAbsolutePath = true;\n      return FileError._sanitizedEnvironmentVariable;\n    } else if (result.index !== 0) {\n      // Currently only support the token being first in the string.\n      throw new Error(\n        `The ${baseFolderEnvVar} environment variable contains text before the token \"${result[0]}\".`\n      );\n    } else if (result[0].length !== FileError._sanitizedEnvironmentVariable!.length) {\n      // Currently only support the token being the entire string.\n      throw new Error(\n        `The ${baseFolderEnvVar} environment variable contains text after the token \"${result[0]}\".`\n      );\n    } else {\n      throw new Error(\n        `The ${baseFolderEnvVar} environment variable contains a token \"${result[0]}\", which is not ` +\n          'supported.'\n      );\n    }\n  }\n\n  public static [Symbol.hasInstance](instance: object): boolean {\n    return TypeUuid.isInstanceOf(instance, uuidFileError);\n  }\n}\n\nTypeUuid.registerClass(FileError, uuidFileError);\n"]}