{"version":3,"file":"Text.js","sourceRoot":"","sources":["../src/Text.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as os from 'os';\n\n/**\n * The allowed types of encodings, as supported by Node.js\n * @public\n */\nexport enum Encoding {\n  Utf8 = 'utf8'\n}\n\n/**\n * Enumeration controlling conversion of newline characters.\n * @public\n */\nexport enum NewlineKind {\n  /**\n   * Windows-style newlines\n   */\n  CrLf = '\\r\\n',\n\n  /**\n   * POSIX-style newlines\n   *\n   * @remarks\n   * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.\n   */\n  Lf = '\\n',\n\n  /**\n   * Default newline type for this operating system (`os.EOL`).\n   */\n  OsDefault = 'os'\n}\n\n/**\n * Options used when calling the {@link Text.readLinesFromIterable} or\n * {@link Text.readLinesFromIterableAsync} methods.\n *\n * @public\n */\nexport interface IReadLinesFromIterableOptions {\n  /**\n   * The encoding of the input iterable. The default is utf8.\n   */\n  encoding?: Encoding;\n\n  /**\n   * If true, empty lines will not be returned. The default is false.\n   */\n  ignoreEmptyLines?: boolean;\n}\n\ninterface IReadLinesFromIterableState {\n  remaining: string;\n}\n\nconst NEWLINE_REGEX: RegExp = /\\r\\n|\\n\\r|\\r|\\n/g;\nconst NEWLINE_AT_END_REGEX: RegExp = /(\\r\\n|\\n\\r|\\r|\\n)$/;\n\nfunction* readLinesFromChunk(\n  // eslint-disable-next-line @rushstack/no-new-null\n  chunk: string | Buffer | null,\n  encoding: Encoding,\n  ignoreEmptyLines: boolean,\n  state: IReadLinesFromIterableState\n): Generator<string> {\n  if (!chunk) {\n    return;\n  }\n  const remaining: string = state.remaining + (typeof chunk === 'string' ? chunk : chunk.toString(encoding));\n  let startIndex: number = 0;\n  const matches: IterableIterator<RegExpMatchArray> = remaining.matchAll(NEWLINE_REGEX);\n  for (const match of matches) {\n    const endIndex: number = match.index!;\n    if (startIndex !== endIndex || !ignoreEmptyLines) {\n      yield remaining.substring(startIndex, endIndex);\n    }\n    startIndex = endIndex + match[0].length;\n  }\n  state.remaining = remaining.substring(startIndex);\n}\n\n/**\n * Operations for working with strings that contain text.\n *\n * @remarks\n * The utilities provided by this class are intended to be simple, small, and very\n * broadly applicable.\n *\n * @public\n */\nexport class Text {\n  private static readonly _newLineRegEx: RegExp = NEWLINE_REGEX;\n  private static readonly _newLineAtEndRegEx: RegExp = NEWLINE_AT_END_REGEX;\n\n  /**\n   * Returns the same thing as targetString.replace(searchValue, replaceValue), except that\n   * all matches are replaced, rather than just the first match.\n   * @param input         - The string to be modified\n   * @param searchValue   - The value to search for\n   * @param replaceValue  - The replacement text\n   */\n  public static replaceAll(input: string, searchValue: string, replaceValue: string): string {\n    return input.split(searchValue).join(replaceValue);\n  }\n\n  /**\n   * Converts all newlines in the provided string to use Windows-style CRLF end of line characters.\n   */\n  public static convertToCrLf(input: string): string {\n    return input.replace(Text._newLineRegEx, '\\r\\n');\n  }\n\n  /**\n   * Converts all newlines in the provided string to use POSIX-style LF end of line characters.\n   *\n   * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.\n   */\n  public static convertToLf(input: string): string {\n    return input.replace(Text._newLineRegEx, '\\n');\n  }\n\n  /**\n   * Converts all newlines in the provided string to use the specified newline type.\n   */\n  public static convertTo(input: string, newlineKind: NewlineKind): string {\n    return input.replace(Text._newLineRegEx, Text.getNewline(newlineKind));\n  }\n\n  /**\n   * Returns the newline character sequence for the specified `NewlineKind`.\n   */\n  public static getNewline(newlineKind: NewlineKind): string {\n    switch (newlineKind) {\n      case NewlineKind.CrLf:\n        return '\\r\\n';\n      case NewlineKind.Lf:\n        return '\\n';\n      case NewlineKind.OsDefault:\n        return os.EOL;\n      default:\n        throw new Error('Unsupported newline kind');\n    }\n  }\n\n  /**\n   * Append characters to the end of a string to ensure the result has a minimum length.\n   * @remarks\n   * If the string length already exceeds the minimum length, then the string is unchanged.\n   * The string is not truncated.\n   */\n  public static padEnd(s: string, minimumLength: number, paddingCharacter: string = ' '): string {\n    if (paddingCharacter.length !== 1) {\n      throw new Error('The paddingCharacter parameter must be a single character.');\n    }\n\n    if (s.length < minimumLength) {\n      const paddingArray: string[] = new Array(minimumLength - s.length);\n      paddingArray.unshift(s);\n      return paddingArray.join(paddingCharacter);\n    } else {\n      return s;\n    }\n  }\n\n  /**\n   * Append characters to the start of a string to ensure the result has a minimum length.\n   * @remarks\n   * If the string length already exceeds the minimum length, then the string is unchanged.\n   * The string is not truncated.\n   */\n  public static padStart(s: string, minimumLength: number, paddingCharacter: string = ' '): string {\n    if (paddingCharacter.length !== 1) {\n      throw new Error('The paddingCharacter parameter must be a single character.');\n    }\n\n    if (s.length < minimumLength) {\n      const paddingArray: string[] = new Array(minimumLength - s.length);\n      paddingArray.push(s);\n      return paddingArray.join(paddingCharacter);\n    } else {\n      return s;\n    }\n  }\n\n  /**\n   * If the string is longer than maximumLength characters, truncate it to that length\n   * using \"...\" to indicate the truncation.\n   *\n   * @remarks\n   * For example truncateWithEllipsis('1234578', 5) would produce '12...'.\n   */\n  public static truncateWithEllipsis(s: string, maximumLength: number): string {\n    if (maximumLength < 0) {\n      throw new Error('The maximumLength cannot be a negative number');\n    }\n\n    if (s.length <= maximumLength) {\n      return s;\n    }\n\n    if (s.length <= 3) {\n      return s.substring(0, maximumLength);\n    }\n\n    return s.substring(0, maximumLength - 3) + '...';\n  }\n\n  /**\n   * Returns the input string with a trailing `\\n` character appended, if not already present.\n   */\n  public static ensureTrailingNewline(s: string, newlineKind: NewlineKind = NewlineKind.Lf): string {\n    // Is there already a newline?\n    if (Text._newLineAtEndRegEx.test(s)) {\n      return s; // yes, no change\n    }\n    return s + newlineKind; // no, add it\n  }\n\n  /**\n   * Escapes a string so that it can be treated as a literal string when used in a regular expression.\n   */\n  public static escapeRegExp(literal: string): string {\n    return literal.replace(/[^A-Za-z0-9_]/g, '\\\\$&');\n  }\n\n  /**\n   * Read lines from an iterable object that returns strings or buffers, and return a generator that\n   * produces the lines as strings. The lines will not include the newline characters.\n   *\n   * @param iterable - An iterable object that returns strings or buffers\n   * @param options - Options used when reading the lines from the provided iterable\n   */\n  public static async *readLinesFromIterableAsync(\n    iterable: AsyncIterable<string | Buffer>,\n    options: IReadLinesFromIterableOptions = {}\n  ): AsyncGenerator<string> {\n    const { encoding = Encoding.Utf8, ignoreEmptyLines = false } = options;\n    const state: IReadLinesFromIterableState = { remaining: '' };\n    for await (const chunk of iterable) {\n      yield* readLinesFromChunk(chunk, encoding, ignoreEmptyLines, state);\n    }\n    const remaining: string = state.remaining;\n    if (remaining.length) {\n      yield remaining;\n    }\n  }\n\n  /**\n   * Read lines from an iterable object that returns strings or buffers, and return a generator that\n   * produces the lines as strings. The lines will not include the newline characters.\n   *\n   * @param iterable - An iterable object that returns strings or buffers\n   * @param options - Options used when reading the lines from the provided iterable\n   */\n  public static *readLinesFromIterable(\n    // eslint-disable-next-line @rushstack/no-new-null\n    iterable: Iterable<string | Buffer | null>,\n    options: IReadLinesFromIterableOptions = {}\n  ): Generator<string> {\n    const { encoding = Encoding.Utf8, ignoreEmptyLines = false } = options;\n    const state: IReadLinesFromIterableState = { remaining: '' };\n    for (const chunk of iterable) {\n      yield* readLinesFromChunk(chunk, encoding, ignoreEmptyLines, state);\n    }\n    const remaining: string = state.remaining;\n    if (remaining.length) {\n      yield remaining;\n    }\n  }\n\n  /**\n   * Returns a new string that is the input string with the order of characters reversed.\n   */\n  public static reverse(s: string): string {\n    // Benchmarks of several algorithms: https://jsbench.me/4bkfflcm2z\n    return s.split('').reduce((newString, char) => char + newString, '');\n  }\n\n  /**\n   * Splits the provided string by newlines. Note that leading and trailing newlines will produce\n   * leading or trailing empty string array entries.\n   */\n  public static splitByNewLines(s: undefined): undefined;\n  public static splitByNewLines(s: string): string[];\n  public static splitByNewLines(s: string | undefined): string[] | undefined;\n  public static splitByNewLines(s: string | undefined): string[] | undefined {\n    return s?.split(/\\r?\\n/);\n  }\n}\n"]}