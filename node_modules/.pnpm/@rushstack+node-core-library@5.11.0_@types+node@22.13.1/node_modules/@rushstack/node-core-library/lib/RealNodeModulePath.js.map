{"version":3,"file":"RealNodeModulePath.js","sourceRoot":"","sources":["../src/RealNodeModulePath.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as nodeFs from 'fs';\nimport * as nodePath from 'path';\n\n/**\n * Arguments used to create a function that resolves symlinked node_modules in a path\n * @public\n */\nexport interface IRealNodeModulePathResolverOptions {\n  fs?: Partial<Pick<typeof nodeFs, 'lstatSync' | 'readlinkSync'>>;\n  path?: Partial<Pick<typeof nodePath, 'isAbsolute' | 'join' | 'resolve' | 'sep'>>;\n}\n\n/**\n * This class encapsulates a caching resolver for symlinks in node_modules directories.\n * It assumes that the only symlinks that exist in input paths are those that correspond to\n * npm packages.\n *\n * @remarks\n * In a repository with a symlinked node_modules installation, some symbolic links need to be mapped for\n * node module resolution to produce correct results. However, calling `fs.realpathSync.native` on every path,\n * as is commonly done by most resolvers, involves an enormous number of file system operations (for reference,\n * each invocation of `fs.realpathSync.native` involves a series of `fs.readlinkSync` calls, up to one for each\n * path segment in the input).\n *\n * @public\n */\nexport class RealNodeModulePathResolver {\n  /**\n   * Similar in function to `fs.realpathSync.native`, but assumes the only symlinks present are npm packages.\n   *\n   * @param input - A path to a file or directory, where the path separator is `${require('node:path').sep}`\n   * @returns The real path to the input, resolving the node_modules symlinks in the path\n   * @public\n   */\n  public readonly realNodeModulePath: (input: string) => string;\n\n  private readonly _cache: Map<string, string>;\n  private readonly _fs: Required<NonNullable<IRealNodeModulePathResolverOptions['fs']>>;\n  private readonly _path: Required<NonNullable<IRealNodeModulePathResolverOptions['path']>>;\n\n  public constructor(options: IRealNodeModulePathResolverOptions = {}) {\n    const {\n      fs: { lstatSync = nodeFs.lstatSync, readlinkSync = nodeFs.readlinkSync } = nodeFs,\n      path: {\n        isAbsolute = nodePath.isAbsolute,\n        join = nodePath.join,\n        resolve = nodePath.resolve,\n        sep = nodePath.sep\n      } = nodePath\n    } = options;\n    const cache: Map<string, string> = (this._cache = new Map());\n    this._fs = {\n      lstatSync,\n      readlinkSync\n    };\n    this._path = {\n      isAbsolute,\n      join,\n      resolve,\n      sep\n    };\n\n    const nodeModulesToken: string = `${sep}node_modules${sep}`;\n    const self: this = this;\n\n    function realNodeModulePathInternal(input: string): string {\n      // Find the last node_modules path segment\n      const nodeModulesIndex: number = input.lastIndexOf(nodeModulesToken);\n      if (nodeModulesIndex < 0) {\n        // No node_modules in path, so we assume it is already the real path\n        return input;\n      }\n\n      // First assume that the next path segment after node_modules is a symlink\n      let linkStart: number = nodeModulesIndex + nodeModulesToken.length - 1;\n      let linkEnd: number = input.indexOf(sep, linkStart + 1);\n      // If the path segment starts with a '@', then it is a scoped package\n      const isScoped: boolean = input.charAt(linkStart + 1) === '@';\n      if (isScoped) {\n        // For a scoped package, the scope is an ordinary directory, so we need to find the next path segment\n        if (linkEnd < 0) {\n          // Symlink missing, so see if anything before the last node_modules needs resolving,\n          // and preserve the rest of the path\n          return join(\n            realNodeModulePathInternal(input.slice(0, nodeModulesIndex)),\n            input.slice(nodeModulesIndex + 1),\n            // Joining to `.` will clean up any extraneous trailing slashes\n            '.'\n          );\n        }\n\n        linkStart = linkEnd;\n        linkEnd = input.indexOf(sep, linkStart + 1);\n      }\n\n      // No trailing separator, so the link is the last path segment\n      if (linkEnd < 0) {\n        linkEnd = input.length;\n      }\n\n      const linkCandidate: string = input.slice(0, linkEnd);\n      // Check if the link is a symlink\n      const linkTarget: string | undefined = self._tryReadLink(linkCandidate);\n      if (linkTarget && isAbsolute(linkTarget)) {\n        // Absolute path, combine the link target with any remaining path segments\n        // Cache the resolution to avoid the readlink call in subsequent calls\n        cache.set(linkCandidate, linkTarget);\n        cache.set(linkTarget, linkTarget);\n        // Joining to `.` will clean up any extraneous trailing slashes\n        return join(linkTarget, input.slice(linkEnd + 1), '.');\n      }\n\n      // Relative path or does not exist\n      // Either way, the path before the last node_modules could itself be in a node_modules folder\n      // So resolve the base path to find out what paths are relative to\n      const realpathBeforeNodeModules: string = realNodeModulePathInternal(input.slice(0, nodeModulesIndex));\n      if (linkTarget) {\n        // Relative path in symbolic link. Should be resolved relative to real path of base path.\n        const resolvedTarget: string = resolve(\n          realpathBeforeNodeModules,\n          input.slice(nodeModulesIndex + 1, linkStart),\n          linkTarget\n        );\n        // Cache the result of the combined resolution to avoid the readlink call in subsequent calls\n        cache.set(linkCandidate, resolvedTarget);\n        cache.set(resolvedTarget, resolvedTarget);\n        // Joining to `.` will clean up any extraneous trailing slashes\n        return join(resolvedTarget, input.slice(linkEnd + 1), '.');\n      }\n\n      // No symlink, so just return the real path before the last node_modules combined with the\n      // subsequent path segments\n      // Joining to `.` will clean up any extraneous trailing slashes\n      return join(realpathBeforeNodeModules, input.slice(nodeModulesIndex + 1), '.');\n    }\n\n    this.realNodeModulePath = (input: string) => {\n      return realNodeModulePathInternal(resolve(input));\n    };\n  }\n\n  /**\n   * Clears the cache of resolved symlinks.\n   * @public\n   */\n  public clearCache(): void {\n    this._cache.clear();\n  }\n\n  /**\n   * Tries to read a symbolic link at the specified path.\n   * If the input is not a symbolic link, returns undefined.\n   * @param link - The link to try to read\n   * @returns The target of the symbolic link, or undefined if the input is not a symbolic link\n   */\n  private _tryReadLink(link: string): string | undefined {\n    const cached: string | undefined = this._cache.get(link);\n    if (cached) {\n      return cached;\n    }\n\n    // On Windows, calling `readlink` on a directory throws an EUNKOWN, not EINVAL, so just pay the cost\n    // of an lstat call.\n    const stat: nodeFs.Stats | undefined = this._fs.lstatSync(link);\n    if (stat.isSymbolicLink()) {\n      // path.join(x, '.') will trim trailing slashes, if applicable\n      const result: string = this._path.join(this._fs.readlinkSync(link, 'utf8'), '.');\n      return result;\n    }\n  }\n}\n"]}