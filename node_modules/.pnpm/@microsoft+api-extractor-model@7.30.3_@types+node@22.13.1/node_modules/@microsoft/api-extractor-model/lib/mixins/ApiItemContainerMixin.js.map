{"version":3,"file":"ApiItemContainerMixin.js","sourceRoot":"","sources":["../../src/mixins/ApiItemContainerMixin.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAE3D,oDAAoD;AAEpD,8CAO0B;AAC1B,iDAA8C;AAK9C,uCAAgE;AAChE,+DAI+B;AAC/B,oEAA6D;AAmB7D,MAAM,QAAQ,GAAkB,MAAM,CAAC,gCAAgC,CAAC,CAAC;AACzE,MAAM,cAAc,GAAkB,MAAM,CAAC,sCAAsC,CAAC,CAAC;AACrF,MAAM,sBAAsB,GAAkB,MAAM,CAAC,8CAA8C,CAAC,CAAC;AACrG,MAAM,cAAc,GAAkB,MAAM,CAAC,sCAAsC,CAAC,CAAC;AACrF,MAAM,cAAc,GAAkB,MAAM,CAAC,sCAAsC,CAAC,CAAC;AACrF,MAAM,oBAAoB,GAAkB,MAAM,CAAC,4CAA4C,CAAC,CAAC;AAmIjG;;;;;;;GAOG;AACH,SAAgB,qBAAqB,CACnC,SAAqB;AACrB,8DAA8D;;IAE9D,MAAM,UAAW,SAAQ,SAAS;QAchC,8DAA8D;QAC9D,YAAmB,GAAG,IAAW;;YAC/B,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;YACf,MAAM,OAAO,GAAkC,IAAI,CAAC,CAAC,CAAkC,CAAC;YAExF,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC;YACpB,IAAI,CAAC,cAAc,CAAC,GAAG,KAAK,CAAC;YAC7B,IAAI,CAAC,sBAAsB,CAAC,GAAG,IAAI,GAAG,EAAmB,CAAC;YAC1D,IAAI,CAAC,oBAAoB,CAAC,GAAG,MAAA,OAAO,CAAC,mBAAmB,mCAAI,KAAK,CAAC;YAElE,IAAI,OAAO,CAAC,OAAO,EAAE,CAAC;gBACpB,KAAK,MAAM,MAAM,IAAI,OAAO,CAAC,OAAO,EAAE,CAAC;oBACrC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;gBACzB,CAAC;YACH,CAAC;QACH,CAAC;QAED,gBAAgB;QACT,MAAM,CAAC,iBAAiB,CAC7B,OAA+C,EAC/C,OAA4B,EAC5B,UAAiC;YAEjC,SAAS,CAAC,iBAAiB,CAAC,OAAO,EAAE,OAAO,EAAE,UAAU,CAAC,CAAC;YAC1D,OAAO,CAAC,mBAAmB,GAAG,UAAU,CAAC,mBAAmB,CAAC;YAC7D,OAAO,CAAC,OAAO,GAAG,EAAE,CAAC;YACrB,KAAK,MAAM,YAAY,IAAI,UAAU,CAAC,OAAO,EAAE,CAAC;gBAC9C,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,iBAAO,CAAC,WAAW,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC,CAAC;YACnE,CAAC;QACH,CAAC;QAED,gBAAgB;QAChB,IAAW,OAAO;YAChB,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,EAAE,CAAC;gBACzD,IAAI,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC,aAAa,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC;gBAC5E,IAAI,CAAC,cAAc,CAAC,GAAG,IAAI,CAAC;YAC9B,CAAC;YAED,OAAO,IAAI,CAAC,QAAQ,CAAC,CAAC;QACxB,CAAC;QAED,IAAW,mBAAmB;YAC5B,OAAO,IAAI,CAAC,oBAAoB,CAAC,CAAC;QACpC,CAAC;QAEM,SAAS,CAAC,MAAe;YAC9B,IAAI,IAAI,CAAC,sBAAsB,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,YAAY,CAAC,EAAE,CAAC;gBAC1D,MAAM,IAAI,KAAK,CACb,6DAA6D,MAAM,CAAC,WAAW,GAAG;oBAChF,sBAAsB,MAAM,CAAC,YAAY,GAAG,CAC/C,CAAC;YACJ,CAAC;YAED,MAAM,cAAc,GAAwB,MAAM,CAAC,MAAM,CAAC;YAC1D,IAAI,cAAc,KAAK,SAAS,EAAE,CAAC;gBACjC,MAAM,IAAI,KAAK,CACb,2DAA2D,cAAc,CAAC,WAAW,GAAG,CACzF,CAAC;YACJ,CAAC;YAED,IAAI,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC5B,IAAI,CAAC,cAAc,CAAC,GAAG,SAAS,CAAC,CAAC,wBAAwB;YAC1D,IAAI,CAAC,cAAc,CAAC,GAAG,SAAS,CAAC,CAAC,wBAAwB;YAC1D,IAAI,CAAC,cAAc,CAAC,GAAG,KAAK,CAAC;YAC7B,IAAI,CAAC,sBAAsB,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC;YAE9D,MAAM,CAAC,iCAAuB,CAAC,CAAC,IAAI,CAAC,CAAC;QACxC,CAAC;QAEM,iBAAiB,CAAC,YAAoB;YAC3C,OAAO,IAAI,CAAC,sBAAsB,CAAC,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QACxD,CAAC;QAEM,iBAAiB,CAAC,IAAY;YACnC,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACzB,OAAO,IAAI,CAAC,cAAc,CAAE,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;QAC/C,CAAC;QAEM,0BAA0B;YAC/B,MAAM,QAAQ,GAA2B,EAAE,CAAC;YAC5C,IAAI,qBAAqB,GAAY,KAAK,CAAC;YAE3C,oFAAoF;YACpF,qBAAqB;YACrB,QAAQ,IAAI,CAAC,IAAI,EAAE,CAAC;gBAClB,KAAK,qBAAW,CAAC,KAAK,CAAC;gBACvB,KAAK,qBAAW,CAAC,SAAS;oBACxB,MAAM;gBACR,OAAO,CAAC,CAAC,CAAC;oBACR,OAAO;wBACL,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;wBAC5B,QAAQ;wBACR,qBAAqB;qBACtB,CAAC;gBACJ,CAAC;YACH,CAAC;YAED,MAAM,aAAa,GAA2B,IAAI,GAAG,EAAE,CAAC;YACxD,MAAM,aAAa,GAAgC,IAAI,GAAG,EAAE,CAAC;YAE7D,MAAM,OAAO,GAAc,EAAE,CAAC;YAC9B,IAAI,IAAI,GAAwB,IAAI,CAAC;YAErC,OAAO,IAAI,EAAE,CAAC;gBACZ,MAAM,YAAY,GAAc,EAAE,CAAC;gBAEnC,kFAAkF;gBAClF,mFAAmF;gBACnF,6CAA6C;gBAC7C,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC;oBAClC,iFAAiF;oBACjF,yEAAyE;oBACzE,IAAI,2BAAY,CAAC,aAAa,CAAC,MAAM,CAAC,EAAE,CAAC;wBACvC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC;4BACpC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;wBAC5B,CAAC;oBACH,CAAC;yBAAM,CAAC;wBACN,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC;4BACpC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;wBAC5B,CAAC;oBACH,CAAC;gBACH,CAAC;gBAED,KAAK,MAAM,MAAM,IAAI,YAAY,EAAE,CAAC;oBAClC,IAAI,2BAAY,CAAC,aAAa,CAAC,MAAM,CAAC,EAAE,CAAC;wBACvC,MAAM,OAAO,GAAc,aAAa,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;wBAChE,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;wBACrB,aAAa,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;oBAC1C,CAAC;yBAAM,CAAC;wBACN,MAAM,OAAO,GAAc,aAAa,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;wBAChE,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;wBACrB,aAAa,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;oBAC1C,CAAC;gBACH,CAAC;gBAED,6EAA6E;gBAC7E,MAAM,aAAa,GAAc,EAAE,CAAC;gBACpC,IAAI,YAAiD,CAAC;gBAEtD,QAAQ,IAAI,CAAC,IAAI,EAAE,CAAC;oBAClB,KAAK,qBAAW,CAAC,KAAK,CAAC,CAAC,CAAC;wBACvB,MAAM,QAAQ,GAAa,IAAgB,CAAC;wBAC5C,YAAY,GAAG,QAAQ,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;wBAClE,MAAM;oBACR,CAAC;oBACD,KAAK,qBAAW,CAAC,SAAS,CAAC,CAAC,CAAC;wBAC3B,MAAM,YAAY,GAAiB,IAAoB,CAAC;wBACxD,YAAY,GAAG,YAAY,CAAC,YAAY,CAAC;wBACzC,MAAM;oBACR,CAAC;gBACH,CAAC;gBAED,IAAI,YAAY,KAAK,SAAS,EAAE,CAAC;oBAC/B,QAAQ,CAAC,IAAI,CAAC;wBACZ,SAAS,EAAE,2CAAqB,CAAC,eAAe;wBAChD,IAAI,EAAE,4CAA4C,IAAI,CAAC,WAAW,sCAAsC,IAAI,CAAC,IAAI,EAAE;qBACpH,CAAC,CAAC;oBACH,qBAAqB,GAAG,IAAI,CAAC;oBAC7B,IAAI,GAAG,OAAO,CAAC,KAAK,EAAE,CAAC;oBACvB,SAAS;gBACX,CAAC;gBAED,KAAK,MAAM,WAAW,IAAI,YAAY,EAAE,CAAC;oBACvC,wFAAwF;oBACxF,4EAA4E;oBAC5E,EAAE;oBACF,MAAM;oBACN,8BAA8B;oBAC9B,2BAA2B;oBAC3B,iCAAiC;oBACjC,2BAA2B;oBAC3B,gCAAgC;oBAChC,6BAA6B;oBAC7B,MAAM;oBACN,MAAM,mBAAmB,GAA6B,WAAW,CAAC,OAAO,CAAC,aAAa,CAAC,IAAI,CAC1F,CAAC,KAAmB,EAAE,EAAE;wBACtB,OAAO,KAAK,CAAC,IAAI,KAAK,0BAAgB,CAAC,SAAS,IAAI,KAAK,CAAC,kBAAkB,CAAC;oBAC/E,CAAC,CACF,CAAC;oBAEF,IAAI,CAAC,mBAAmB,EAAE,CAAC;wBACzB,QAAQ,CAAC,IAAI,CAAC;4BACZ,SAAS,EAAE,2CAAqB,CAAC,6BAA6B;4BAC9D,IAAI,EAAE,oCAAoC,WAAW,CAAC,OAAO,CAAC,IAAI,gBAAgB,IAAI,CAAC,WAAW,2CAA2C;yBAC9I,CAAC,CAAC;wBACH,qBAAqB,GAAG,IAAI,CAAC;wBAC7B,SAAS;oBACX,CAAC;oBAED,MAAM,QAAQ,GAAyB,IAAI,CAAC,kBAAkB,EAAE,CAAC;oBACjE,IAAI,CAAC,QAAQ,EAAE,CAAC;wBACd,QAAQ,CAAC,IAAI,CAAC;4BACZ,SAAS,EAAE,2CAAqB,CAAC,oBAAoB;4BACrD,IAAI,EAAE,4CAA4C,IAAI,CAAC,WAAW,gDAAgD;yBACnH,CAAC,CAAC;wBACH,qBAAqB,GAAG,IAAI,CAAC;wBAC7B,SAAS;oBACX,CAAC;oBAED,MAAM,kBAAkB,GAAyB,mBAAmB,CAAC,kBAAmB,CAAC;oBACzF,MAAM,aAAa,GAAuC,QAAQ,CAAC,2BAA2B,CAC5F,kBAAkB,EAClB,SAAS,CACV,CAAC;oBAEF,MAAM,OAAO,GAAwB,aAAa,CAAC,eAAe,CAAC;oBACnE,IAAI,CAAC,OAAO,EAAE,CAAC;wBACb,QAAQ,CAAC,IAAI,CAAC;4BACZ,SAAS,EAAE,2CAAqB,CAAC,2BAA2B;4BAC5D,IAAI,EAAE,2DAA2D,IAAI,CAAC,WAAW,KAAK,aAAa,CAAC,YAAY,EAAE;yBACnH,CAAC,CAAC;wBACH,qBAAqB,GAAG,IAAI,CAAC;wBAC7B,SAAS;oBACX,CAAC;oBAED,aAAa,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBAC9B,CAAC;gBAED,+GAA+G;gBAC/G,yGAAyG;gBACzG,gHAAgH;gBAChH,8DAA8D;gBAC9D,EAAE;gBACF,gGAAgG;gBAChG,EAAE;gBACF,MAAM;gBACN,kBAAkB;gBAClB,sBAAsB;gBACtB,IAAI;gBACJ,EAAE;gBACF,kBAAkB;gBAClB,sBAAsB;gBACtB,IAAI;gBACJ,EAAE;gBACF,uCAAuC;gBACvC,MAAM;gBACN,aAAa,CAAC,IAAI,CAAC,CAAC,CAAU,EAAE,CAAU,EAAE,EAAE,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC,aAAa,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC;gBAE7F,OAAO,CAAC,IAAI,CAAC,GAAG,aAAa,CAAC,CAAC;gBAC/B,IAAI,GAAG,OAAO,CAAC,KAAK,EAAE,CAAC;YACzB,CAAC;YAED,MAAM,KAAK,GAAc,EAAE,CAAC;YAC5B,KAAK,MAAM,OAAO,IAAI,aAAa,CAAC,MAAM,EAAE,EAAE,CAAC;gBAC7C,KAAK,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,CAAC;YACzB,CAAC;YACD,KAAK,MAAM,OAAO,IAAI,aAAa,CAAC,MAAM,EAAE,EAAE,CAAC;gBAC7C,KAAK,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,CAAC;YACzB,CAAC;YACD,KAAK,CAAC,IAAI,CAAC,CAAC,CAAU,EAAE,CAAU,EAAE,EAAE,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC,aAAa,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC;YAErF,OAAO;gBACL,KAAK;gBACL,QAAQ;gBACR,qBAAqB;aACtB,CAAC;QACJ,CAAC;QAED,gBAAgB;QACT,2BAA2B,CAAC,aAAsB;YACvD,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACzB,IAAI,MAA6B,CAAC;YAClC,IAAI,2BAAY,CAAC,aAAa,CAAC,aAAa,CAAC,EAAE,CAAC;gBAC9C,MAAM,GAAG,IAAI,CAAC,cAAc,CAAE,CAAC,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;YACzD,CAAC;iBAAM,CAAC;gBACN,MAAM,GAAG,IAAI,CAAC,cAAc,CAAE,CAAC,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;YACzD,CAAC;YACD,IAAI,CAAC,MAAM,EAAE,CAAC;gBACZ,MAAM,IAAI,iCAAa,CAAC,gEAAgE,CAAC,CAAC;YAC5F,CAAC;YACD,OAAO,MAAM,CAAC;QAChB,CAAC;QAED,gBAAgB;QACT,iBAAiB;YACtB,iFAAiF;YACjF,IAAI,IAAI,CAAC,cAAc,CAAC,KAAK,SAAS,EAAE,CAAC;gBACvC,MAAM,aAAa,GAA2B,IAAI,GAAG,EAAqB,CAAC;gBAC3E,MAAM,aAAa,GAA2B,IAAI,GAAG,EAAqB,CAAC;gBAE3E,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC;oBACpC,IAAI,GAAyD,CAAC;oBAC9D,IAAI,GAAyB,CAAC;oBAE9B,IAAI,2BAAY,CAAC,aAAa,CAAC,MAAM,CAAC,EAAE,CAAC;wBACvC,GAAG,GAAG,aAAa,CAAC;wBACpB,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC;oBACpB,CAAC;yBAAM,CAAC;wBACN,GAAG,GAAG,aAAa,CAAC;wBACpB,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC;oBACpB,CAAC;oBAED,IAAI,IAAI,GAA0B,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;oBAC/C,IAAI,IAAI,KAAK,SAAS,EAAE,CAAC;wBACvB,IAAI,GAAG,EAAE,CAAC;wBACV,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;oBACrB,CAAC;oBACD,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBACpB,CAAC;gBAED,IAAI,CAAC,cAAc,CAAC,GAAG,aAAa,CAAC;gBACrC,IAAI,CAAC,cAAc,CAAC,GAAG,aAAa,CAAC;YACvC,CAAC;QACH,CAAC;QAED,gBAAgB;QACT,aAAa,CAAC,UAA0C;YAC7D,KAAK,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;YAEhC,MAAM,aAAa,GAAmB,EAAE,CAAC;YAEzC,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC;gBAClC,MAAM,gBAAgB,GAA0B,EAAE,CAAC;gBACnD,MAAM,CAAC,aAAa,CAAC,gBAAgB,CAAC,CAAC;gBACvC,aAAa,CAAC,IAAI,CAAC,gBAAgC,CAAC,CAAC;YACvD,CAAC;YAED,UAAU,CAAC,mBAAmB,GAAG,IAAI,CAAC,mBAAmB,CAAC;YAC1D,UAAU,CAAC,OAAO,GAAG,aAAa,CAAC;QACrC,CAAC;KACF;IAED,OAAO,UAAU,CAAC;AACpB,CAAC;AArVD,sDAqVC;AAED;;;GAGG;AACH,WAAiB,qBAAqB;IACpC;;;;;;;;OAQG;IACH,SAAgB,aAAa,CAAC,OAAgB;QAC5C,OAAO,OAAO,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;IAC1C,CAAC;IAFe,mCAAa,gBAE5B,CAAA;AACH,CAAC,EAbgB,qBAAqB,qCAArB,qBAAqB,QAarC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/* eslint-disable @typescript-eslint/no-redeclare */\n\nimport {\n  ApiItem,\n  apiItem_onParentChanged,\n  type IApiItemJson,\n  type IApiItemOptions,\n  type IApiItemConstructor,\n  ApiItemKind\n} from '../items/ApiItem';\nimport { ApiNameMixin } from './ApiNameMixin';\nimport type { DeserializerContext } from '../model/DeserializerContext';\nimport type { ApiModel } from '../model/ApiModel';\nimport type { ApiClass } from '../model/ApiClass';\nimport type { ApiInterface } from '../model/ApiInterface';\nimport { type ExcerptToken, ExcerptTokenKind } from './Excerpt';\nimport {\n  type IFindApiItemsResult,\n  type IFindApiItemsMessage,\n  FindApiItemsMessageId\n} from './IFindApiItemsResult';\nimport { InternalError } from '@rushstack/node-core-library';\nimport type { DeclarationReference } from '@microsoft/tsdoc/lib-commonjs/beta/DeclarationReference';\nimport type { HeritageType } from '../model/HeritageType';\nimport type { IResolveDeclarationReferenceResult } from '../model/ModelReferenceResolver';\n\n/**\n * Constructor options for {@link (ApiItemContainerMixin:interface)}.\n * @public\n */\nexport interface IApiItemContainerMixinOptions extends IApiItemOptions {\n  preserveMemberOrder?: boolean;\n  members?: ApiItem[];\n}\n\nexport interface IApiItemContainerJson extends IApiItemJson {\n  preserveMemberOrder?: boolean;\n  members: IApiItemJson[];\n}\n\nconst _members: unique symbol = Symbol('ApiItemContainerMixin._members');\nconst _membersSorted: unique symbol = Symbol('ApiItemContainerMixin._membersSorted');\nconst _membersByContainerKey: unique symbol = Symbol('ApiItemContainerMixin._membersByContainerKey');\nconst _membersByName: unique symbol = Symbol('ApiItemContainerMixin._membersByName');\nconst _membersByKind: unique symbol = Symbol('ApiItemContainerMixin._membersByKind');\nconst _preserveMemberOrder: unique symbol = Symbol('ApiItemContainerMixin._preserveMemberOrder');\n\n/**\n * The mixin base class for API items that act as containers for other child items.\n *\n * @remarks\n *\n * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of\n * API declarations.  The non-abstract classes (e.g. `ApiClass`, `ApiEnum`, `ApiInterface`, etc.) use\n * TypeScript \"mixin\" functions (e.g. `ApiDeclaredItem`, `ApiItemContainerMixin`, etc.) to add various\n * features that cannot be represented as a normal inheritance chain (since TypeScript does not allow a child class\n * to extend more than one base class).  The \"mixin\" is a TypeScript merged declaration with three components:\n * the function that generates a subclass, an interface that describes the members of the subclass, and\n * a namespace containing static members of the class.\n *\n * Examples of `ApiItemContainerMixin` child classes include `ApiModel`, `ApiPackage`, `ApiEntryPoint`,\n * and `ApiEnum`.  But note that `Parameter` is not considered a \"member\" of an `ApiMethod`; this relationship\n * is modeled using {@link (ApiParameterListMixin:interface).parameters} instead\n * of {@link ApiItem.members}.\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport interface ApiItemContainerMixin extends ApiItem {\n  /**\n   * Disables automatic sorting of {@link ApiItem.members}.\n   *\n   * @remarks\n   * By default `ApiItemContainerMixin` will automatically sort its members according to their\n   * {@link ApiItem.getSortKey} string, which provides a standardized mostly alphabetical ordering\n   * that is appropriate for most API items.  When loading older .api.json files the automatic sorting\n   * is reapplied and may update the ordering.\n   *\n   * Set `preserveMemberOrder` to true to disable automatic sorting for this container; instead, the\n   * members will retain whatever ordering appeared in the {@link IApiItemContainerMixinOptions.members} array.\n   * The `preserveMemberOrder` option is saved in the .api.json file.\n   */\n  readonly preserveMemberOrder: boolean;\n\n  /**\n   * Adds a new member to the container.\n   *\n   * @remarks\n   * An ApiItem cannot be added to more than one container.\n   */\n  addMember(member: ApiItem): void;\n\n  /**\n   * Attempts to retrieve a member using its containerKey, or returns `undefined` if no matching member was found.\n   *\n   * @remarks\n   * Use the `getContainerKey()` static member to construct the key.  Each subclass has a different implementation\n   * of this function, according to the aspects that are important for identifying it.\n   *\n   * See {@link ApiItem.containerKey} for more information.\n   */\n  tryGetMemberByKey(containerKey: string): ApiItem | undefined;\n\n  /**\n   * Returns a list of members with the specified name.\n   */\n  findMembersByName(name: string): ReadonlyArray<ApiItem>;\n\n  /**\n   * Finds all of the ApiItem's immediate and inherited members by walking up the inheritance tree.\n   *\n   * @remarks\n   *\n   * Given the following class heritage:\n   *\n   * ```\n   * export class A {\n   *   public a: number|boolean;\n   * }\n   *\n   * export class B extends A {\n   *   public a: number;\n   *   public b: string;\n   * }\n   *\n   * export class C extends B {\n   *   public c: boolean;\n   * }\n   * ```\n   *\n   * Calling `findMembersWithInheritance` on `C` will return `B.a`, `B.b`, and `C.c`. Calling the\n   * method on `B` will return `B.a` and `B.b`. And calling the method on `A` will return just\n   * `A.a`.\n   *\n   * The inherited members returned by this method may be incomplete. If so, there will be a flag\n   * on the result object indicating this as well as messages explaining the errors in more detail.\n   * Some scenarios include:\n   *\n   * - Interface extending from a type alias.\n   *\n   * - Class extending from a variable.\n   *\n   * - Extending from a declaration not present in the model (e.g. external package).\n   *\n   * - Extending from an unexported declaration (e.g. ae-forgotten-export). Common in mixin\n   *   patterns.\n   *\n   * - Unexpected runtime errors...\n   *\n   * Lastly, be aware that the types of inherited members are returned with respect to their\n   * defining class as opposed to with respect to the inheriting class. For example, consider\n   * the following:\n   *\n   * ```\n   * export class A<T> {\n   *   public a: T;\n   * }\n   *\n   * export class B extends A<number> {}\n   * ```\n   *\n   * When called on `B`, this method will return `B.a` with type `T` as opposed to type\n   * `number`, although the latter is more accurate.\n   */\n  findMembersWithInheritance(): IFindApiItemsResult;\n\n  /**\n   * For a given member of this container, return its `ApiItem.getMergedSiblings()` list.\n   * @internal\n   */\n  _getMergedSiblingsForMember(memberApiItem: ApiItem): ReadonlyArray<ApiItem>;\n\n  /** @override */\n  serializeInto(jsonObject: Partial<IApiItemJson>): void;\n}\n\n/**\n * Mixin function for {@link ApiDeclaredItem}.\n *\n * @param baseClass - The base class to be extended\n * @returns A child class that extends baseClass, adding the {@link (ApiItemContainerMixin:interface)} functionality.\n *\n * @public\n */\nexport function ApiItemContainerMixin<TBaseClass extends IApiItemConstructor>(\n  baseClass: TBaseClass\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): TBaseClass & (new (...args: any[]) => ApiItemContainerMixin) {\n  class MixedClass extends baseClass implements ApiItemContainerMixin {\n    public readonly [_members]: ApiItem[];\n    public [_membersSorted]: boolean;\n    public [_membersByContainerKey]: Map<string, ApiItem>;\n    public [_preserveMemberOrder]: boolean;\n\n    // For members of this container that extend ApiNameMixin, this stores the list of members with a given name.\n    // Examples include merged declarations, overloaded functions, etc.\n    public [_membersByName]: Map<string, ApiItem[]> | undefined;\n\n    // For members of this container that do NOT extend ApiNameMixin, this stores the list of members\n    // that share a common ApiItemKind.  Examples include overloaded constructors or index signatures.\n    public [_membersByKind]: Map<string, ApiItem[]> | undefined; // key is ApiItemKind\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    public constructor(...args: any[]) {\n      super(...args);\n      const options: IApiItemContainerMixinOptions = args[0] as IApiItemContainerMixinOptions;\n\n      this[_members] = [];\n      this[_membersSorted] = false;\n      this[_membersByContainerKey] = new Map<string, ApiItem>();\n      this[_preserveMemberOrder] = options.preserveMemberOrder ?? false;\n\n      if (options.members) {\n        for (const member of options.members) {\n          this.addMember(member);\n        }\n      }\n    }\n\n    /** @override */\n    public static onDeserializeInto(\n      options: Partial<IApiItemContainerMixinOptions>,\n      context: DeserializerContext,\n      jsonObject: IApiItemContainerJson\n    ): void {\n      baseClass.onDeserializeInto(options, context, jsonObject);\n      options.preserveMemberOrder = jsonObject.preserveMemberOrder;\n      options.members = [];\n      for (const memberObject of jsonObject.members) {\n        options.members.push(ApiItem.deserialize(memberObject, context));\n      }\n    }\n\n    /** @override */\n    public get members(): ReadonlyArray<ApiItem> {\n      if (!this[_membersSorted] && !this[_preserveMemberOrder]) {\n        this[_members].sort((x, y) => x.getSortKey().localeCompare(y.getSortKey()));\n        this[_membersSorted] = true;\n      }\n\n      return this[_members];\n    }\n\n    public get preserveMemberOrder(): boolean {\n      return this[_preserveMemberOrder];\n    }\n\n    public addMember(member: ApiItem): void {\n      if (this[_membersByContainerKey].has(member.containerKey)) {\n        throw new Error(\n          `Another member has already been added with the same name (${member.displayName})` +\n            ` and containerKey (${member.containerKey})`\n        );\n      }\n\n      const existingParent: ApiItem | undefined = member.parent;\n      if (existingParent !== undefined) {\n        throw new Error(\n          `This item has already been added to another container: \"${existingParent.displayName}\"`\n        );\n      }\n\n      this[_members].push(member);\n      this[_membersByName] = undefined; // invalidate the lookup\n      this[_membersByKind] = undefined; // invalidate the lookup\n      this[_membersSorted] = false;\n      this[_membersByContainerKey].set(member.containerKey, member);\n\n      member[apiItem_onParentChanged](this);\n    }\n\n    public tryGetMemberByKey(containerKey: string): ApiItem | undefined {\n      return this[_membersByContainerKey].get(containerKey);\n    }\n\n    public findMembersByName(name: string): ReadonlyArray<ApiItem> {\n      this._ensureMemberMaps();\n      return this[_membersByName]!.get(name) || [];\n    }\n\n    public findMembersWithInheritance(): IFindApiItemsResult {\n      const messages: IFindApiItemsMessage[] = [];\n      let maybeIncompleteResult: boolean = false;\n\n      // For API items that don't support inheritance, this method just returns the item's\n      // immediate members.\n      switch (this.kind) {\n        case ApiItemKind.Class:\n        case ApiItemKind.Interface:\n          break;\n        default: {\n          return {\n            items: this.members.concat(),\n            messages,\n            maybeIncompleteResult\n          };\n        }\n      }\n\n      const membersByName: Map<string, ApiItem[]> = new Map();\n      const membersByKind: Map<ApiItemKind, ApiItem[]> = new Map();\n\n      const toVisit: ApiItem[] = [];\n      let next: ApiItem | undefined = this;\n\n      while (next) {\n        const membersToAdd: ApiItem[] = [];\n\n        // For each member, check to see if we've already seen a member with the same name\n        // previously in the inheritance tree. If so, we know we won't inherit it, and thus\n        // do not add it to our `membersToAdd` array.\n        for (const member of next.members) {\n          // We add the to-be-added members to an intermediate array instead of immediately\n          // to the maps themselves to support method overloads with the same name.\n          if (ApiNameMixin.isBaseClassOf(member)) {\n            if (!membersByName.has(member.name)) {\n              membersToAdd.push(member);\n            }\n          } else {\n            if (!membersByKind.has(member.kind)) {\n              membersToAdd.push(member);\n            }\n          }\n        }\n\n        for (const member of membersToAdd) {\n          if (ApiNameMixin.isBaseClassOf(member)) {\n            const members: ApiItem[] = membersByName.get(member.name) || [];\n            members.push(member);\n            membersByName.set(member.name, members);\n          } else {\n            const members: ApiItem[] = membersByKind.get(member.kind) || [];\n            members.push(member);\n            membersByKind.set(member.kind, members);\n          }\n        }\n\n        // Interfaces can extend multiple interfaces, so iterate through all of them.\n        const extendedItems: ApiItem[] = [];\n        let extendsTypes: readonly HeritageType[] | undefined;\n\n        switch (next.kind) {\n          case ApiItemKind.Class: {\n            const apiClass: ApiClass = next as ApiClass;\n            extendsTypes = apiClass.extendsType ? [apiClass.extendsType] : [];\n            break;\n          }\n          case ApiItemKind.Interface: {\n            const apiInterface: ApiInterface = next as ApiInterface;\n            extendsTypes = apiInterface.extendsTypes;\n            break;\n          }\n        }\n\n        if (extendsTypes === undefined) {\n          messages.push({\n            messageId: FindApiItemsMessageId.UnsupportedKind,\n            text: `Unable to analyze references of API item ${next.displayName} because it is of unsupported kind ${next.kind}`\n          });\n          maybeIncompleteResult = true;\n          next = toVisit.shift();\n          continue;\n        }\n\n        for (const extendsType of extendsTypes) {\n          // We want to find the reference token associated with the actual inherited declaration.\n          // In every case we support, this is the first reference token. For example:\n          //\n          // ```\n          // export class A extends B {}\n          //                        ^\n          // export class A extends B<C> {}\n          //                        ^\n          // export class A extends B.C {}\n          //                        ^^^\n          // ```\n          const firstReferenceToken: ExcerptToken | undefined = extendsType.excerpt.spannedTokens.find(\n            (token: ExcerptToken) => {\n              return token.kind === ExcerptTokenKind.Reference && token.canonicalReference;\n            }\n          );\n\n          if (!firstReferenceToken) {\n            messages.push({\n              messageId: FindApiItemsMessageId.ExtendsClauseMissingReference,\n              text: `Unable to analyze extends clause ${extendsType.excerpt.text} of API item ${next.displayName} because no canonical reference was found`\n            });\n            maybeIncompleteResult = true;\n            continue;\n          }\n\n          const apiModel: ApiModel | undefined = this.getAssociatedModel();\n          if (!apiModel) {\n            messages.push({\n              messageId: FindApiItemsMessageId.NoAssociatedApiModel,\n              text: `Unable to analyze references of API item ${next.displayName} because it is not associated with an ApiModel`\n            });\n            maybeIncompleteResult = true;\n            continue;\n          }\n\n          const canonicalReference: DeclarationReference = firstReferenceToken.canonicalReference!;\n          const apiItemResult: IResolveDeclarationReferenceResult = apiModel.resolveDeclarationReference(\n            canonicalReference,\n            undefined\n          );\n\n          const apiItem: ApiItem | undefined = apiItemResult.resolvedApiItem;\n          if (!apiItem) {\n            messages.push({\n              messageId: FindApiItemsMessageId.DeclarationResolutionFailed,\n              text: `Unable to resolve declaration reference within API item ${next.displayName}: ${apiItemResult.errorMessage}`\n            });\n            maybeIncompleteResult = true;\n            continue;\n          }\n\n          extendedItems.push(apiItem);\n        }\n\n        // For classes, this array will only have one item. For interfaces, there may be multiple items. Sort the array\n        // into alphabetical order before adding to our list of API items to visit. This ensures that in the case\n        // of multiple interface inheritance, a member inherited from multiple interfaces is attributed to the interface\n        // earlier in alphabetical order (as opposed to source order).\n        //\n        // For example, in the code block below, `Bar.x` is reported as the inherited item, not `Foo.x`.\n        //\n        // ```\n        // interface Foo {\n        //   public x: string;\n        // }\n        //\n        // interface Bar {\n        //   public x: string;\n        // }\n        //\n        // interface FooBar extends Foo, Bar {}\n        // ```\n        extendedItems.sort((x: ApiItem, y: ApiItem) => x.getSortKey().localeCompare(y.getSortKey()));\n\n        toVisit.push(...extendedItems);\n        next = toVisit.shift();\n      }\n\n      const items: ApiItem[] = [];\n      for (const members of membersByName.values()) {\n        items.push(...members);\n      }\n      for (const members of membersByKind.values()) {\n        items.push(...members);\n      }\n      items.sort((x: ApiItem, y: ApiItem) => x.getSortKey().localeCompare(y.getSortKey()));\n\n      return {\n        items,\n        messages,\n        maybeIncompleteResult\n      };\n    }\n\n    /** @internal */\n    public _getMergedSiblingsForMember(memberApiItem: ApiItem): ReadonlyArray<ApiItem> {\n      this._ensureMemberMaps();\n      let result: ApiItem[] | undefined;\n      if (ApiNameMixin.isBaseClassOf(memberApiItem)) {\n        result = this[_membersByName]!.get(memberApiItem.name);\n      } else {\n        result = this[_membersByKind]!.get(memberApiItem.kind);\n      }\n      if (!result) {\n        throw new InternalError('Item was not found in the _membersByName/_membersByKind lookup');\n      }\n      return result;\n    }\n\n    /** @internal */\n    public _ensureMemberMaps(): void {\n      // Build the _membersByName and _membersByKind tables if they don't already exist\n      if (this[_membersByName] === undefined) {\n        const membersByName: Map<string, ApiItem[]> = new Map<string, ApiItem[]>();\n        const membersByKind: Map<string, ApiItem[]> = new Map<string, ApiItem[]>();\n\n        for (const member of this[_members]) {\n          let map: Map<string, ApiItem[]> | Map<ApiItemKind, ApiItem[]>;\n          let key: string | ApiItemKind;\n\n          if (ApiNameMixin.isBaseClassOf(member)) {\n            map = membersByName;\n            key = member.name;\n          } else {\n            map = membersByKind;\n            key = member.kind;\n          }\n\n          let list: ApiItem[] | undefined = map.get(key);\n          if (list === undefined) {\n            list = [];\n            map.set(key, list);\n          }\n          list.push(member);\n        }\n\n        this[_membersByName] = membersByName;\n        this[_membersByKind] = membersByKind;\n      }\n    }\n\n    /** @override */\n    public serializeInto(jsonObject: Partial<IApiItemContainerJson>): void {\n      super.serializeInto(jsonObject);\n\n      const memberObjects: IApiItemJson[] = [];\n\n      for (const member of this.members) {\n        const memberJsonObject: Partial<IApiItemJson> = {};\n        member.serializeInto(memberJsonObject);\n        memberObjects.push(memberJsonObject as IApiItemJson);\n      }\n\n      jsonObject.preserveMemberOrder = this.preserveMemberOrder;\n      jsonObject.members = memberObjects;\n    }\n  }\n\n  return MixedClass;\n}\n\n/**\n * Static members for {@link (ApiItemContainerMixin:interface)}.\n * @public\n */\nexport namespace ApiItemContainerMixin {\n  /**\n   * A type guard that tests whether the specified `ApiItem` subclass extends the `ApiItemContainerMixin` mixin.\n   *\n   * @remarks\n   *\n   * The JavaScript `instanceof` operator cannot be used to test for mixin inheritance, because each invocation of\n   * the mixin function produces a different subclass.  (This could be mitigated by `Symbol.hasInstance`, however\n   * the TypeScript type system cannot invoke a runtime test.)\n   */\n  export function isBaseClassOf(apiItem: ApiItem): apiItem is ApiItemContainerMixin {\n    return apiItem.hasOwnProperty(_members);\n  }\n}\n"]}