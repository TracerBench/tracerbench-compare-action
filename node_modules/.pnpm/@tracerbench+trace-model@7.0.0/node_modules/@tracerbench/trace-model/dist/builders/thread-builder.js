"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bounds_1 = require("../util/bounds");
class ThreadModelImpl {
    constructor(process, { tid, name, sortIndex, start, end, events }) {
        this.process = process;
        this.id = tid;
        this.name = name;
        this.sortIndex = sortIndex;
        this.start = start;
        this.end = end;
        this.events = events;
    }
    get duration() {
        return this.end - this.start;
    }
    get isRendererMain() {
        return this.name === "CrRendererMain" /* THREAD_NAME_RENDERER_MAIN */;
    }
}
class ThreadBuilder {
    constructor(pid, tid) {
        this.bounds = undefined;
        this.name = '';
        this.sortIndex = 0;
        this.events = [];
        this.stack = [];
        this.pid = pid;
        this.tid = tid;
    }
    get start() {
        var _a, _b;
        return (_b = (_a = this.bounds) === null || _a === void 0 ? void 0 : _a.start) !== null && _b !== void 0 ? _b : 0;
    }
    get end() {
        var _a, _b;
        return (_b = (_a = this.bounds) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : 0;
    }
    addMetadata(event) {
        switch (event.name) {
            case "thread_name" /* METADATA_NAME_THREAD_NAME */:
                this.name = event.getStringArg("name" /* METADATA_ARG_NAME */, '');
                break;
            case "thread_sort_index" /* METADATA_NAME_THREAD_SORT_INDEX */:
                this.sortIndex = event.getNumberArg("sort_index" /* METADATA_ARG_SORT_INDEX */, 0);
                break;
        }
    }
    extendBounds(event) {
        if (this.bounds === undefined) {
            this.bounds = new bounds_1.default(event.start, event.end);
        }
        else {
            this.bounds.extend(event.start, event.end);
        }
    }
    addEvent(event) {
        this.events.push(event);
        if (event.isComplete()) {
            const { stack } = this;
            const { end } = event;
            for (let i = stack.length - 1; i >= 0; i--) {
                const parent = stack[i];
                if (end <= parent.end) {
                    event.parent = parent;
                    break;
                }
                else {
                    stack.pop();
                }
            }
            stack.push(event);
        }
    }
    build(process) {
        return new ThreadModelImpl(process, this);
    }
}
exports.default = ThreadBuilder;
//# sourceMappingURL=thread-builder.js.map