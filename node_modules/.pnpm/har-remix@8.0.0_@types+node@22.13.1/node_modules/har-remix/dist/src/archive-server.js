"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const http_1 = require("http");
const mime_types_1 = require("mime-types");
const zlib_1 = require("zlib");
class ArchiveServer {
    constructor(delegate) {
        this.delegate = delegate;
        this.responses = createMap();
    }
    loadArchive(path) {
        this.addArchive(JSON.parse(fs_1.readFileSync(path, 'utf8')));
    }
    addArchive(har) {
        this.addArchiveEntries(har.log.entries);
    }
    addArchiveEntries(entries) {
        for (const entry of entries) {
            this.addArchiveEntry(entry);
        }
    }
    addArchiveEntry(entry) {
        const key = this.delegate.keyForArchiveEntry(entry);
        if (!key) {
            return;
        }
        const response = this.buildResponseForArchiveEntry(entry, key);
        if (response) {
            this.addResponse(key, response);
        }
        else {
            // tslint:disable-next-line: no-console
            console.error(`unable to build response for key: ${key}`);
        }
    }
    buildResponseForArchiveEntry(entry, key) {
        const { status, content } = entry.response;
        if (content && status >= 200 && status < 300) {
            let { text } = content;
            const { encoding, mimeType } = content;
            let body;
            if (text === undefined) {
                body = undefined;
            }
            else if (mime_types_1.charset(mimeType) === 'UTF-8') {
                text = new Buffer(text, encoding).toString();
                if (this.delegate.textFor) {
                    text = this.delegate.textFor(entry, key, text);
                }
                body = new Buffer(text);
            }
            else {
                body = new Buffer(text, encoding);
            }
            const compress = content.compression !== undefined && content.compression > 0;
            let response = this.buildResponse(status, mimeType, body, compress);
            if (this.delegate.finalizeResponse) {
                response = this.delegate.finalizeResponse(entry, key, response);
            }
            return response;
        }
        if (this.delegate.responseFor) {
            return this.delegate.responseFor(entry, key);
        }
    }
    buildResponse(statusCode, mimeType, body, compress) {
        let headers;
        if (body && compress) {
            body = zlib_1.gzipSync(body, {
                level: 9
            });
            headers = this.buildHeaders(mimeType, body, true);
        }
        else {
            headers = this.buildHeaders(mimeType, body, false);
        }
        return { statusCode, headers, body };
    }
    buildHeaders(mimeType, body, compressed) {
        const headers = {
            'Content-Length': '' + (body ? body.byteLength : 0),
            'Content-Type': mimeType
        };
        if (compressed) {
            headers['Content-Encoding'] = 'gzip';
        }
        return headers;
    }
    addResponse(key, response) {
        // tslint:disable-next-line: no-console
        console.log(`add:  ${key}`);
        this.responses[key] = response;
    }
    setResponse(key, response) {
        // tslint:disable-next-line: no-console
        console.log(`set:  ${key}`);
        this.responses[key] = response;
    }
    responseFor(key) {
        return this.responses[key];
    }
    async handle(request, response) {
        const key = await Promise.resolve(this.delegate.keyForServerRequest(request));
        if (key) {
            const res = this.responseFor(key);
            if (res) {
                // tslint:disable-next-line: no-console
                console.log(`hit:  ${key}`);
                response.writeHead(res.statusCode, res.headers);
                response.end(res.body);
            }
            else {
                // tslint:disable-next-line: no-console
                console.log(`miss: ${key}`);
            }
        }
        if (this.delegate.missingResponse && !response.headersSent) {
            await Promise.resolve(this.delegate.missingResponse(request, response));
        }
        if (!response.headersSent) {
            response.writeHead(404);
            response.end();
        }
        // tslint:disable-next-line: no-console
        console.log(response.statusCode, request.method, request.url);
    }
    createServer() {
        return http_1.createServer((req, res) => this.handle(req, res));
    }
}
exports.default = ArchiveServer;
function createMap() {
    return Object.create(null);
}
//# sourceMappingURL=archive-server.js.map