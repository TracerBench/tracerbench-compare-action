"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenerateStats = void 0;
const stats_1 = require("@tracerbench/stats");
const utils_1 = require("../helpers/utils");
// takes control/experimentData as raw samples in microseconds
class GenerateStats {
    constructor(controlData, experimentData, reportTitles) {
        this.controlData = controlData;
        this.experimentData = experimentData;
        this.reportTitles = reportTitles;
        const { durationSection, subPhaseSections } = this.generateData(this.controlData.samples, this.experimentData.samples, this.reportTitles);
        this.durationSection = durationSection;
        this.subPhaseSections = subPhaseSections;
        this.cumulativeData = this.bucketCumulative(this.controlData.samples, this.experimentData.samples);
    }
    generateData(controlDataSamples, experimentDataSamples, reportTitles) {
        const valuesByPhaseControl = this.bucketPhaseValues(controlDataSamples);
        const valuesByPhaseExperiment = this.bucketPhaseValues(experimentDataSamples);
        const subPhases = Object.keys(valuesByPhaseControl).filter((k) => k !== "duration");
        const durationSection = this.formatPhaseData(valuesByPhaseControl["duration"], valuesByPhaseExperiment["duration"], "duration");
        const subPhaseSections = subPhases.map((phase) => {
            const controlValues = valuesByPhaseControl[phase];
            const experimentValues = valuesByPhaseExperiment[phase];
            const renderDataForPhase = this.formatPhaseData(controlValues, experimentValues, phase);
            renderDataForPhase.servers = reportTitles.servers;
            return renderDataForPhase;
        });
        durationSection.servers = reportTitles.servers;
        return {
            durationSection,
            subPhaseSections,
        };
    }
    /**
     * Extract the phases and page load time latency into sorted buckets by phase
     *
     * @param samples - Array of "sample" objects
     * @param valueGen - Calls this function to extract the value from the phase. A
     *   "phase" is passed containing duration and start
     */
    bucketPhaseValues(samples, valueGen = (a) => a.duration) {
        const buckets = { ["duration"]: [] };
        samples.forEach((sample) => {
            buckets["duration"].push(sample["duration"]);
            sample.phases.forEach((phaseData) => {
                const bucket = buckets[phaseData.phase] || [];
                bucket.push(valueGen(phaseData));
                buckets[phaseData.phase] = bucket;
            });
        });
        return buckets;
    }
    /**
     * Instantiate the TB Stats Class. Format the data into HTMLSectionRenderData
     * structure.
     *
     * @param controlValues - Values for the control for the phase in microseconds not arranged
     * @param experimentValues - Values for the experiment for the phase in microseconds not arranged
     * @param phaseName - Name of the phase the values represent
     */
    formatPhaseData(controlValues, experimentValues, phaseName) {
        // all stats will be converted to milliseconds and rounded to tenths
        const stats = new stats_1.Stats({
            control: controlValues,
            experiment: experimentValues,
            name: phaseName,
        }, stats_1.roundFloatAndConvertMicrosecondsToMS);
        const estimatorIsSig = Math.abs(stats.estimator) >= 1 ? true : false;
        const frequency = {
            labels: [],
            control: [],
            experiment: [],
        };
        stats.buckets.map((bucket) => {
            frequency.labels.push(`${bucket.min}-${bucket.max} ms`);
            frequency.control.push(bucket.count.control);
            frequency.experiment.push(bucket.count.experiment);
        });
        return {
            stats,
            phase: phaseName,
            identifierHash: (0, utils_1.md5sum)(phaseName),
            frequencyHash: (0, utils_1.md5sum)(`${phaseName}-frequency`),
            isSignificant: stats.confidenceInterval.isSig && estimatorIsSig,
            sampleCount: stats.sampleCount.control,
            ciMin: stats.confidenceInterval.min,
            ciMax: stats.confidenceInterval.max,
            pValue: stats.confidenceInterval.pValue,
            hlDiff: stats.estimator,
            servers: undefined,
            asPercent: stats.confidenceInterval.asPercent,
            frequency,
            controlFormatedSamples: {
                min: stats.sevenFigureSummary.control.min,
                q1: stats.sevenFigureSummary.control[25],
                median: stats.sevenFigureSummary.control[50],
                q3: stats.sevenFigureSummary.control[75],
                max: stats.sevenFigureSummary.control.max,
                outliers: stats.outliers.control.outliers,
                samplesMS: stats.control,
            },
            experimentFormatedSamples: {
                min: stats.sevenFigureSummary.experiment.min,
                q1: stats.sevenFigureSummary.experiment[25],
                median: stats.sevenFigureSummary.experiment[50],
                q3: stats.sevenFigureSummary.experiment[75],
                max: stats.sevenFigureSummary.experiment.max,
                outliers: stats.outliers.experiment.outliers,
                samplesMS: stats.experiment,
            },
        };
    }
    /**
     * Bucket the data for the cumulative chart. Ensure to convert to
     * milliseconds for presentation. Does not mutate samples.
     */
    bucketCumulative(controlDataSamples, experimentDataSamples) {
        // round and convert from micro to milliseconds
        const cumulativeValueFunc = (a) => Math.round((0, stats_1.convertMicrosecondsToMS)(a.start + a.duration));
        const valuesByPhaseControl = this.bucketPhaseValues(controlDataSamples, cumulativeValueFunc);
        const valuesByPhaseExperiment = this.bucketPhaseValues(experimentDataSamples, cumulativeValueFunc);
        const phases = Object.keys(valuesByPhaseControl).filter((k) => k !== "duration");
        return {
            categories: phases,
            controlData: phases.map((k) => valuesByPhaseControl[k]),
            experimentData: phases.map((k) => valuesByPhaseExperiment[k]),
        };
    }
}
exports.GenerateStats = GenerateStats;
//# sourceMappingURL=generate-stats.js.map