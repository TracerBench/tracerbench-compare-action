"use strict";
/* eslint-disable filenames/match-exported */
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = require("fs-extra");
const Handlebars = require("handlebars");
const path_1 = require("path");
const html_minifier_terser_1 = require("html-minifier-terser");
const command_config_1 = require("../../command-config");
const generate_stats_1 = require("../../compare/generate-stats");
const parse_compare_result_1 = require("../../compare/parse-compare-result");
const print_to_pdf_1 = require("../../compare/print-to-pdf");
const flags_1 = require("../../helpers/flags");
const utils_1 = require("../../helpers/utils");
const static_1 = require("../../static");
// HANDLEBARS HELPERS
Handlebars.registerPartial("phaseChartJSSection", static_1.PHASE_CHART_JS_TEMPLATE_RAW);
Handlebars.registerPartial("phaseDetailSection", static_1.PHASE_DETAIL_TEMPLATE_RAW);
Handlebars.registerHelper("toCamel", (val) => {
    return val.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
});
Handlebars.registerHelper("isFaster", (analysis) => {
    return analysis.hlDiff > 0;
});
Handlebars.registerHelper("getQuality", (pVal, threshold) => {
    return pVal < threshold;
});
Handlebars.registerHelper("abs", (num) => {
    return Math.abs(num);
});
Handlebars.registerHelper("absSort", (num1, num2, position) => {
    const sorted = [Math.abs(num1), Math.abs(num2)];
    sorted.sort((a, b) => a - b);
    return sorted[position];
});
Handlebars.registerHelper("stringify", (ctx) => {
    return JSON.stringify(ctx);
});
Handlebars.registerHelper("logArr", (arr) => {
    return JSON.stringify(arr);
});
// CONSTANTS
const ARTIFACT_FILE_NAME = "artifact";
class CompareReport extends command_config_1.TBBaseCommand {
    constructor(argv, config) {
        super(argv, config);
        const { flags } = this.parse(CompareReport);
        this.reportFlags = flags;
    }
    // instantiated before this.run()
    async init() {
        const { flags } = this.parse(CompareReport);
        this.parsedConfig = (0, command_config_1.getConfig)(flags.config, flags, this.explicitFlags);
        await this.parseFlags();
    }
    async run() {
        const { tbResultsFolder } = this.parsedConfig;
        const inputFilePath = (0, path_1.join)(tbResultsFolder, "compare.json");
        const { controlData, experimentData } = (0, parse_compare_result_1.default)(inputFilePath);
        const { absOutputPath, absPathToHTML } = await this.printPDF(controlData, experimentData, tbResultsFolder);
        if (!this.parsedConfig.isCIEnv) {
            this.logReportPaths(tbResultsFolder, absOutputPath, absPathToHTML);
        }
    }
    logReportPaths(tbResultsFolder, absOutputPath, absPathToHTML) {
        const chalkBlueBold = utils_1.chalkScheme.tbBranding.blue.underline.bold;
        (0, utils_1.logHeading)("Benchmark Reports");
        this.log(`\nJSON: ${chalkBlueBold(`${tbResultsFolder}/compare.json`)}`);
        this.log(`\nPDF: ${chalkBlueBold(absOutputPath)}`);
        this.log(`\nHTML: ${chalkBlueBold(absPathToHTML)}\n`);
    }
    async printPDF(controlData, experimentData, tbResultsFolder) {
        const outputFileName = this.determineOutputFileNamePrefix(tbResultsFolder);
        const renderedHTML = this.createConsumableHTML(controlData, experimentData, this.parsedConfig, this.reportFlags.plotTitle);
        const minifiedHTML = await (0, html_minifier_terser_1.minify)(renderedHTML, {
            collapseWhitespace: true,
            removeComments: true,
            minifyCSS: true,
            minifyJS: true,
        });
        const absPathToHTML = (0, path_1.resolve)((0, path_1.join)(tbResultsFolder, `/${outputFileName}.html`));
        (0, fs_extra_1.writeFileSync)(absPathToHTML, minifiedHTML);
        const absOutputPath = (0, path_1.resolve)((0, path_1.join)(tbResultsFolder + `/${outputFileName}.pdf`));
        await (0, print_to_pdf_1.default)(`file://${absPathToHTML}`, absOutputPath);
        return {
            absOutputPath,
            absPathToHTML,
        };
    }
    async parseFlags() {
        const { tbResultsFolder } = this.parsedConfig;
        // if the folder for the tracerbench results file
        // does not exist then create it
        try {
            (0, fs_extra_1.mkdirSync)(tbResultsFolder, { recursive: true });
        }
        catch (e) {
            // ignore
        }
    }
    // increment the report filename prefix by 1
    determineOutputFileNamePrefix(outputFolder) {
        let count = 1;
        const running = true;
        while (running) {
            const candidateHTML = (0, path_1.join)(outputFolder, `${ARTIFACT_FILE_NAME}-${count}.html`);
            const candidatePDF = (0, path_1.join)(outputFolder, `${ARTIFACT_FILE_NAME}-${count}.pdf`);
            if (!(0, fs_extra_1.existsSync)(candidateHTML) && !(0, fs_extra_1.existsSync)(candidatePDF)) {
                break;
            }
            count += 1;
        }
        return `artifact-${count}`;
    }
    createConsumableHTML(controlData, experimentData, tbConfig, plotTitle) {
        const version = controlData.meta.browserVersion ||
            controlData.meta["product-version"] ||
            "HeadlessChrome";
        const reportTitles = CompareReport.resolveTitles(tbConfig, version, plotTitle);
        const { durationSection, subPhaseSections, cumulativeData } = new generate_stats_1.GenerateStats(controlData, experimentData, reportTitles);
        const template = Handlebars.compile(static_1.REPORT_TEMPLATE_RAW);
        return template({
            cumulativeData,
            durationSection,
            reportTitles,
            subPhaseSections,
            configsSJSONString: JSON.stringify(tbConfig, null, 4),
            sectionFormattedDataJson: JSON.stringify(subPhaseSections),
        });
    }
    /**
     * Override the default server and plot title attributes
     *
     * @param tbConfig - Concerned only about the "servers" and "plotTitle"
     *   attribute
     * @param version - Browser version
     * @param plotTitle - Optional explicit title from cli flag
     */
    static resolveTitles(tbConfig, version, plotTitle) {
        const reportTitles = {
            servers: [{ name: "Control" }, { name: "Experiment" }],
            plotTitle: tbConfig.plotTitle
                ? tbConfig.plotTitle
                : command_config_1.defaultFlagArgs.plotTitle,
            browserVersion: version,
        };
        if (tbConfig.servers) {
            reportTitles.servers = tbConfig.servers.map((titleConfig, idx) => {
                if (idx === 0) {
                    return { name: `Control: ${titleConfig.name}` };
                }
                else {
                    return { name: `Experiment: ${titleConfig.name}` };
                }
            });
        }
        // if passing an explicit plotTitle via cli flag this trumps
        // the tbConfig.plotTitle and defaults
        if (plotTitle) {
            reportTitles.plotTitle = plotTitle;
        }
        return reportTitles;
    }
}
exports.default = CompareReport;
// alias for API backwards compat
CompareReport.aliases = ["report"];
CompareReport.description = `Generates report files (PDF/HTML) from the "tracerbench compare" command output`;
CompareReport.flags = {
    tbResultsFolder: (0, flags_1.tbResultsFolder)({ required: true }),
    config: (0, flags_1.config)(),
    plotTitle: (0, flags_1.plotTitle)(),
    isCIEnv: (0, flags_1.isCIEnv)(),
};
//# sourceMappingURL=report.js.map