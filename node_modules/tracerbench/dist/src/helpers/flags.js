"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.marker = exports.filename = exports.dest = exports.tracepath = exports.tbconfigpath = exports.cookiespath = exports.emulateDeviceOrientation = exports.emulateDevice = exports.socksPorts = exports.experimentURL = exports.controlURL = exports.url = exports.tbResultsFolder = exports.network = exports.markers = exports.fidelity = exports.cpuThrottleRate = exports.methods = exports.event = exports.appName = exports.browserArgs = exports.sampleTimeout = exports.regressionThreshold = exports.debug = exports.headless = exports.report = exports.config = exports.plotTitle = exports.servers = exports.runtimeStats = exports.hideUsertimings = exports.isCIEnv = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint:disable:no-console*/
const command_1 = require("@oclif/command");
const core_1 = require("@tracerbench/core");
const default_flag_args_1 = require("../command-config/default-flag-args");
const device_settings_1 = require("./device-settings");
const utils_1 = require("./utils");
/*
! oclif oclifFlags.build#parse will only execute when the flag:string is passed directly
! from the cli. thus when passed via the tbconfig.json or the defaultFlagArgs
! the parse method will never execute
! todo: mitigate above by either extending the flags oclif command calling parse
! and type checking in all circumstances
*/
exports.isCIEnv = command_1.flags.build({
    description: `Provides a drastically slimmed down stdout report for CI workflows. However does NOT hide analysis.`,
    default: () => default_flag_args_1.getDefaultValue("isCIEnv"),
    parse: (ci) => {
        // if boolean return
        if (typeof ci === "boolean") {
            return ci;
        }
        // if string return boolean value
        return ci === "true";
    },
});
exports.hideUsertimings = command_1.flags.boolean({
    description: `Hide stdout of user-timings.`,
    default: false,
});
exports.runtimeStats = command_1.flags.boolean({
    description: `Compare command output deep-dive stats during run.`,
    default: false,
});
exports.servers = command_1.flags.build({
    description: `Optional servers config for A/B testing with har-remix dist slicing with socks proxy. All paths within this config are relative.`,
});
exports.plotTitle = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue("plotTitle"),
    description: `Specify the title of the report pdf file.`,
});
exports.config = command_1.flags.build({
    description: `Specify an alternative directory rather than the project root for the tbconfig.json. This explicit config will overwrite all.`,
});
exports.report = command_1.flags.boolean({
    description: `Generate a PDF report directly after running the compare command.`,
    default: false,
});
exports.headless = command_1.flags.boolean({
    description: `Run with headless chrome flags`,
    default: false,
});
exports.debug = command_1.flags.boolean({
    description: `Debug flag per command. Will output noisy command`,
    default: false,
});
exports.regressionThreshold = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue("regressionThreshold"),
    description: `The upper limit the experiment can regress slower in milliseconds. eg 50`,
    parse: (ms) => {
        return parseInt(ms, 10);
    },
});
exports.sampleTimeout = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue("sampleTimeout"),
    description: `The number of seconds to wait for a sample.`,
    parse: (ms) => {
        return parseInt(ms, 10);
    },
});
exports.browserArgs = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue("browserArgs"),
    description: `(Default Recommended) Additional chrome flags for the TracerBench render benchmark. TracerBench includes many non-configurable defaults in this category.`,
    parse: (s) => {
        return s.split(",");
    },
});
exports.appName = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue("appName"),
    description: "The name of your application",
});
exports.event = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue("event"),
    description: "Slice time and see the events before and after the time slice",
});
exports.methods = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue("methods"),
    description: "List of methods to aggregate",
});
exports.cpuThrottleRate = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue("cpuThrottleRate"),
    description: "CPU throttle multiplier",
    parse: (cpuThrottleRate) => {
        return parseInt(cpuThrottleRate, 10);
    },
});
exports.fidelity = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue("fidelity"),
    description: `Directly correlates to the number of samples per trace. eg. ${Object.keys(default_flag_args_1.fidelityLookup)} OR any number between 2-100`,
    parse: (fidelity) => {
        const warnMessage = `Expected --fidelity=${fidelity} to be either a number or one of: ${Object.keys(default_flag_args_1.fidelityLookup)}. Defaulting to ${default_flag_args_1.getDefaultValue("fidelity")}`;
        if (typeof fidelity === "string") {
            // integers are coming as string from oclif
            if (Number.isInteger(parseInt(fidelity, 10))) {
                return parseInt(fidelity, 10);
            }
            // is a string and is either test/low/med/high
            if (Object.keys(default_flag_args_1.fidelityLookup).includes(fidelity)) {
                return parseInt(default_flag_args_1.fidelityLookup[fidelity], 10);
            }
            else {
                console.warn(`${warnMessage}`);
            }
        }
        return fidelity === "number" ? fidelity : default_flag_args_1.getDefaultValue("fidelity");
    },
});
exports.markers = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue("markers"),
    description: "User Timing Markers",
    parse: utils_1.parseMarkers,
});
exports.network = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue("network"),
    description: "Simulated network conditions.",
    options: [
        "none",
        "offline",
        "dialup",
        "slow-2g",
        "2g",
        "slow-edge",
        "edge",
        "slow-3g",
        "dsl",
        "3g",
        "fast-3g",
        "4g",
        "cable",
        "LTE",
        "FIOS",
    ],
    parse: (n) => {
        return core_1.networkConditions[n];
    },
});
exports.tbResultsFolder = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue("tbResultsFolder"),
    description: "The output folder path for all tracerbench results",
});
exports.url = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue("url"),
    description: "URL to visit for record-har, timings & trace commands",
});
exports.controlURL = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue("controlURL"),
    description: "Control URL to visit for compare command",
});
exports.experimentURL = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue("experimentURL"),
    description: "Experiment URL to visit for compare command",
});
exports.socksPorts = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue("socksPorts"),
    description: "Specify a socks proxy port as browser option for control and experiment",
    parse: (s) => {
        if (typeof s === "string") {
            const a = s.split(",");
            if (a.length > 2) {
                console.error(`Maximium of two socks ports can be passed`);
            }
            return [parseInt(a[0], 10), parseInt(a[1], 10)];
        }
    },
});
exports.emulateDevice = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue("emulateDevice"),
    description: `Emulate a mobile device screen size.`,
    options: device_settings_1.default.map((setting) => `${setting.typeable}`),
});
exports.emulateDeviceOrientation = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue("emulateDeviceOrientation"),
    description: `Expected to be either "vertical" or "horizontal". Dictates orientation of device screen.`,
    options: ["horizontal", "vertical"],
});
exports.cookiespath = command_1.flags.build({
    description: `The path to a JSON file containing cookies to authenticate against the correlated URL`,
    default: () => default_flag_args_1.getDefaultValue("cookiespath"),
});
exports.tbconfigpath = command_1.flags.build({
    description: `The path to a TracerBench configuration file (tbconfig.json)`,
});
exports.tracepath = command_1.flags.build({
    description: `The path to the generated trace.json file`,
});
exports.dest = command_1.flags.build({
    default: () => default_flag_args_1.getDefaultValue("dest"),
    description: `The destination path for the generated file`,
});
exports.filename = command_1.flags.build({
    description: `The filename for the generated file`,
});
exports.marker = command_1.flags.build({
    description: `The last marker before ending a HAR recording`,
    default: "loadEventEnd",
});
//# sourceMappingURL=flags.js.map