{"version":3,"file":"ApiModelGenerator.js","sourceRoot":"","sources":["../../src/generators/ApiModelGenerator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/* eslint-disable no-bitwise */\n\nimport * as path from 'path';\nimport * as ts from 'typescript';\nimport type * as tsdoc from '@microsoft/tsdoc';\nimport {\n  ApiModel,\n  ApiClass,\n  ApiPackage,\n  ApiEntryPoint,\n  ApiMethod,\n  ApiNamespace,\n  ApiInterface,\n  ApiPropertySignature,\n  type ApiItemContainerMixin,\n  ReleaseTag,\n  ApiProperty,\n  ApiMethodSignature,\n  type IApiParameterOptions,\n  ApiEnum,\n  ApiEnumMember,\n  type IExcerptTokenRange,\n  type IExcerptToken,\n  ApiConstructor,\n  ApiConstructSignature,\n  ApiFunction,\n  ApiIndexSignature,\n  ApiVariable,\n  ApiTypeAlias,\n  ApiCallSignature,\n  type IApiTypeParameterOptions,\n  EnumMemberOrder\n} from '@microsoft/api-extractor-model';\nimport { Path } from '@rushstack/node-core-library';\n\nimport type { Collector } from '../collector/Collector';\nimport type { ISourceLocation } from '../collector/SourceMapper';\nimport type { AstDeclaration } from '../analyzer/AstDeclaration';\nimport { ExcerptBuilder, type IExcerptBuilderNodeToCapture } from './ExcerptBuilder';\nimport { AstSymbol } from '../analyzer/AstSymbol';\nimport { DeclarationReferenceGenerator } from './DeclarationReferenceGenerator';\nimport type { ApiItemMetadata } from '../collector/ApiItemMetadata';\nimport type { DeclarationMetadata } from '../collector/DeclarationMetadata';\nimport { AstNamespaceImport } from '../analyzer/AstNamespaceImport';\nimport type { AstEntity } from '../analyzer/AstEntity';\nimport type { AstModule } from '../analyzer/AstModule';\nimport { TypeScriptInternals } from '../analyzer/TypeScriptInternals';\n\ninterface IProcessAstEntityContext {\n  name: string;\n  isExported: boolean;\n  parentApiItem: ApiItemContainerMixin;\n}\n\nexport class ApiModelGenerator {\n  private readonly _collector: Collector;\n  private readonly _apiModel: ApiModel;\n  private readonly _referenceGenerator: DeclarationReferenceGenerator;\n\n  public constructor(collector: Collector) {\n    this._collector = collector;\n    this._apiModel = new ApiModel();\n    this._referenceGenerator = new DeclarationReferenceGenerator(collector);\n  }\n\n  public get apiModel(): ApiModel {\n    return this._apiModel;\n  }\n\n  public buildApiPackage(): ApiPackage {\n    const packageDocComment: tsdoc.DocComment | undefined = this._collector.workingPackage.tsdocComment;\n\n    const apiPackage: ApiPackage = new ApiPackage({\n      name: this._collector.workingPackage.name,\n      docComment: packageDocComment,\n      tsdocConfiguration: this._collector.extractorConfig.tsdocConfiguration,\n      projectFolderUrl: this._collector.extractorConfig.projectFolderUrl\n    });\n    this._apiModel.addMember(apiPackage);\n\n    const apiEntryPoint: ApiEntryPoint = new ApiEntryPoint({ name: '' });\n    apiPackage.addMember(apiEntryPoint);\n\n    for (const entity of this._collector.entities) {\n      // Only process entities that are exported from the entry point. Entities that are exported from\n      // `AstNamespaceImport` entities will be processed by `_processAstNamespaceImport`. However, if\n      // we are including forgotten exports, then process everything.\n      if (entity.exportedFromEntryPoint || this._collector.extractorConfig.docModelIncludeForgottenExports) {\n        this._processAstEntity(entity.astEntity, {\n          name: entity.nameForEmit!,\n          isExported: entity.exportedFromEntryPoint,\n          parentApiItem: apiEntryPoint\n        });\n      }\n    }\n\n    return apiPackage;\n  }\n\n  private _processAstEntity(astEntity: AstEntity, context: IProcessAstEntityContext): void {\n    if (astEntity instanceof AstSymbol) {\n      // Skip ancillary declarations; we will process them with the main declaration\n      for (const astDeclaration of this._collector.getNonAncillaryDeclarations(astEntity)) {\n        this._processDeclaration(astDeclaration, context);\n      }\n      return;\n    }\n\n    if (astEntity instanceof AstNamespaceImport) {\n      // Note that a single API item can belong to two different AstNamespaceImport namespaces.  For example:\n      //\n      //   // file.ts defines \"thing()\"\n      //   import * as example1 from \"./file\";\n      //   import * as example2 from \"./file\";\n      //\n      //   // ...so here we end up with example1.thing() and example2.thing()\n      //   export { example1, example2 }\n      //\n      // The current logic does not try to associate \"thing()\" with a specific parent.  Instead\n      // the API documentation will show duplicated entries for example1.thing() and example2.thing().\n      //\n      // This could be improved in the future, but it requires a stable mechanism for choosing an associated parent.\n      // For thoughts about this:  https://github.com/microsoft/rushstack/issues/1308\n      this._processAstNamespaceImport(astEntity, context);\n      return;\n    }\n\n    // TODO: Figure out how to represent reexported AstImport objects.  Basically we need to introduce a new\n    // ApiItem subclass for \"export alias\", similar to a type alias, but representing declarations of the\n    // form \"export { X } from 'external-package'\".  We can also use this to solve GitHub issue #950.\n  }\n\n  private _processAstNamespaceImport(\n    astNamespaceImport: AstNamespaceImport,\n    context: IProcessAstEntityContext\n  ): void {\n    const astModule: AstModule = astNamespaceImport.astModule;\n    const { name, isExported, parentApiItem } = context;\n    const containerKey: string = ApiNamespace.getContainerKey(name);\n    const fileUrlPath: string = this._getFileUrlPath(astNamespaceImport.declaration);\n\n    let apiNamespace: ApiNamespace | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiNamespace;\n\n    if (apiNamespace === undefined) {\n      apiNamespace = new ApiNamespace({\n        name,\n        docComment: undefined,\n        releaseTag: ReleaseTag.None,\n        excerptTokens: [],\n        isExported,\n        fileUrlPath\n      });\n      parentApiItem.addMember(apiNamespace);\n    }\n\n    astModule.astModuleExportInfo!.exportedLocalEntities.forEach(\n      (exportedEntity: AstEntity, exportedName: string) => {\n        this._processAstEntity(exportedEntity, {\n          name: exportedName,\n          isExported: true,\n          parentApiItem: apiNamespace!\n        });\n      }\n    );\n  }\n\n  private _processDeclaration(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    if ((astDeclaration.modifierFlags & ts.ModifierFlags.Private) !== 0) {\n      return; // trim out private declarations\n    }\n\n    const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n    const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n    if (releaseTag === ReleaseTag.Internal) {\n      return; // trim out items marked as \"@internal\"\n    }\n\n    switch (astDeclaration.declaration.kind) {\n      case ts.SyntaxKind.CallSignature:\n        this._processApiCallSignature(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.Constructor:\n        this._processApiConstructor(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.ConstructSignature:\n        this._processApiConstructSignature(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.ClassDeclaration:\n        this._processApiClass(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.EnumDeclaration:\n        this._processApiEnum(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.EnumMember:\n        this._processApiEnumMember(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.FunctionDeclaration:\n        this._processApiFunction(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.GetAccessor:\n        this._processApiProperty(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.SetAccessor:\n        this._processApiProperty(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.IndexSignature:\n        this._processApiIndexSignature(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.InterfaceDeclaration:\n        this._processApiInterface(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.MethodDeclaration:\n        this._processApiMethod(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.MethodSignature:\n        this._processApiMethodSignature(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.ModuleDeclaration:\n        this._processApiNamespace(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.PropertyDeclaration:\n        this._processApiProperty(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.PropertySignature:\n        this._processApiPropertySignature(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.TypeAliasDeclaration:\n        this._processApiTypeAlias(astDeclaration, context);\n        break;\n\n      case ts.SyntaxKind.VariableDeclaration:\n        // check for arrow functions in variable declaration\n        const functionDeclaration: ts.FunctionDeclaration | undefined =\n          this._tryFindFunctionDeclaration(astDeclaration);\n        if (functionDeclaration) {\n          this._processApiFunction(astDeclaration, context, functionDeclaration);\n        } else {\n          this._processApiVariable(astDeclaration, context);\n        }\n        break;\n\n      default:\n      // ignore unknown types\n    }\n  }\n\n  private _tryFindFunctionDeclaration(astDeclaration: AstDeclaration): ts.FunctionDeclaration | undefined {\n    const children: readonly ts.Node[] = astDeclaration.declaration.getChildren(\n      astDeclaration.declaration.getSourceFile()\n    );\n    return children.find(ts.isFunctionTypeNode) as ts.FunctionDeclaration | undefined;\n  }\n\n  private _processChildDeclarations(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    for (const childDeclaration of astDeclaration.children) {\n      this._processDeclaration(childDeclaration, {\n        ...context,\n        name: childDeclaration.astSymbol.localName\n      });\n    }\n  }\n\n  private _processApiCallSignature(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { parentApiItem } = context;\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n    const containerKey: string = ApiCallSignature.getContainerKey(overloadIndex);\n\n    let apiCallSignature: ApiCallSignature | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiCallSignature;\n\n    if (apiCallSignature === undefined) {\n      const callSignature: ts.CallSignatureDeclaration =\n        astDeclaration.declaration as ts.CallSignatureDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: callSignature.type, tokenRange: returnTypeTokenRange });\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        callSignature.typeParameters\n      );\n\n      const parameters: IApiParameterOptions[] = this._captureParameters(\n        nodesToCapture,\n        callSignature.parameters\n      );\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const fileUrlPath: string = this._getFileUrlPath(callSignature);\n\n      apiCallSignature = new ApiCallSignature({\n        docComment,\n        releaseTag,\n        typeParameters,\n        parameters,\n        overloadIndex,\n        excerptTokens,\n        returnTypeTokenRange,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiCallSignature);\n    }\n  }\n\n  private _processApiConstructor(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { parentApiItem } = context;\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n    const containerKey: string = ApiConstructor.getContainerKey(overloadIndex);\n\n    let apiConstructor: ApiConstructor | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiConstructor;\n\n    if (apiConstructor === undefined) {\n      const constructorDeclaration: ts.ConstructorDeclaration =\n        astDeclaration.declaration as ts.ConstructorDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const parameters: IApiParameterOptions[] = this._captureParameters(\n        nodesToCapture,\n        constructorDeclaration.parameters\n      );\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const isProtected: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Protected) !== 0;\n      const fileUrlPath: string = this._getFileUrlPath(constructorDeclaration);\n\n      apiConstructor = new ApiConstructor({\n        docComment,\n        releaseTag,\n        isProtected,\n        parameters,\n        overloadIndex,\n        excerptTokens,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiConstructor);\n    }\n  }\n\n  private _processApiClass(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { name, isExported, parentApiItem } = context;\n    const containerKey: string = ApiClass.getContainerKey(name);\n\n    let apiClass: ApiClass | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiClass;\n\n    if (apiClass === undefined) {\n      const classDeclaration: ts.ClassDeclaration = astDeclaration.declaration as ts.ClassDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        classDeclaration.typeParameters\n      );\n\n      let extendsTokenRange: IExcerptTokenRange | undefined = undefined;\n      const implementsTokenRanges: IExcerptTokenRange[] = [];\n\n      for (const heritageClause of classDeclaration.heritageClauses || []) {\n        if (heritageClause.token === ts.SyntaxKind.ExtendsKeyword) {\n          extendsTokenRange = ExcerptBuilder.createEmptyTokenRange();\n          if (heritageClause.types.length > 0) {\n            nodesToCapture.push({ node: heritageClause.types[0], tokenRange: extendsTokenRange });\n          }\n        } else if (heritageClause.token === ts.SyntaxKind.ImplementsKeyword) {\n          for (const heritageType of heritageClause.types) {\n            const implementsTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n            implementsTokenRanges.push(implementsTokenRange);\n            nodesToCapture.push({ node: heritageType, tokenRange: implementsTokenRange });\n          }\n        }\n      }\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const isAbstract: boolean =\n        (ts.getCombinedModifierFlags(classDeclaration) & ts.ModifierFlags.Abstract) !== 0;\n      const fileUrlPath: string = this._getFileUrlPath(classDeclaration);\n\n      apiClass = new ApiClass({\n        name,\n        isAbstract,\n        docComment,\n        releaseTag,\n        excerptTokens,\n        typeParameters,\n        extendsTokenRange,\n        implementsTokenRanges,\n        isExported,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiClass);\n    }\n\n    this._processChildDeclarations(astDeclaration, {\n      ...context,\n      parentApiItem: apiClass\n    });\n  }\n\n  private _processApiConstructSignature(\n    astDeclaration: AstDeclaration,\n    context: IProcessAstEntityContext\n  ): void {\n    const { parentApiItem } = context;\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n    const containerKey: string = ApiConstructSignature.getContainerKey(overloadIndex);\n\n    let apiConstructSignature: ApiConstructSignature | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiConstructSignature;\n\n    if (apiConstructSignature === undefined) {\n      const constructSignature: ts.ConstructSignatureDeclaration =\n        astDeclaration.declaration as ts.ConstructSignatureDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: constructSignature.type, tokenRange: returnTypeTokenRange });\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        constructSignature.typeParameters\n      );\n\n      const parameters: IApiParameterOptions[] = this._captureParameters(\n        nodesToCapture,\n        constructSignature.parameters\n      );\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const fileUrlPath: string = this._getFileUrlPath(constructSignature);\n\n      apiConstructSignature = new ApiConstructSignature({\n        docComment,\n        releaseTag,\n        typeParameters,\n        parameters,\n        overloadIndex,\n        excerptTokens,\n        returnTypeTokenRange,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiConstructSignature);\n    }\n  }\n\n  private _processApiEnum(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { name, isExported, parentApiItem } = context;\n    const containerKey: string = ApiEnum.getContainerKey(name);\n\n    let apiEnum: ApiEnum | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiEnum;\n\n    if (apiEnum === undefined) {\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, []);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const preserveMemberOrder: boolean =\n        this._collector.extractorConfig.enumMemberOrder === EnumMemberOrder.Preserve;\n      const fileUrlPath: string = this._getFileUrlPath(astDeclaration.declaration);\n\n      apiEnum = new ApiEnum({\n        name,\n        docComment,\n        releaseTag,\n        excerptTokens,\n        preserveMemberOrder,\n        isExported,\n        fileUrlPath\n      });\n      parentApiItem.addMember(apiEnum);\n    }\n\n    this._processChildDeclarations(astDeclaration, {\n      ...context,\n      parentApiItem: apiEnum\n    });\n  }\n\n  private _processApiEnumMember(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { name, parentApiItem } = context;\n    const containerKey: string = ApiEnumMember.getContainerKey(name);\n\n    let apiEnumMember: ApiEnumMember | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiEnumMember;\n\n    if (apiEnumMember === undefined) {\n      const enumMember: ts.EnumMember = astDeclaration.declaration as ts.EnumMember;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      let initializerTokenRange: IExcerptTokenRange | undefined = undefined;\n      if (enumMember.initializer) {\n        initializerTokenRange = ExcerptBuilder.createEmptyTokenRange();\n        nodesToCapture.push({ node: enumMember.initializer, tokenRange: initializerTokenRange });\n      }\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const fileUrlPath: string = this._getFileUrlPath(enumMember);\n\n      apiEnumMember = new ApiEnumMember({\n        name,\n        docComment,\n        releaseTag,\n        excerptTokens,\n        initializerTokenRange,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiEnumMember);\n    }\n  }\n\n  private _processApiFunction(\n    astDeclaration: AstDeclaration,\n    context: IProcessAstEntityContext,\n    altFunctionDeclaration?: ts.FunctionDeclaration\n  ): void {\n    const { name, isExported, parentApiItem } = context;\n\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n    const containerKey: string = ApiFunction.getContainerKey(name, overloadIndex);\n\n    let apiFunction: ApiFunction | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiFunction;\n\n    if (apiFunction === undefined) {\n      const functionDeclaration: ts.FunctionDeclaration =\n        altFunctionDeclaration ?? (astDeclaration.declaration as ts.FunctionDeclaration);\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: functionDeclaration.type, tokenRange: returnTypeTokenRange });\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        functionDeclaration.typeParameters\n      );\n\n      const parameters: IApiParameterOptions[] = this._captureParameters(\n        nodesToCapture,\n        functionDeclaration.parameters\n      );\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const fileUrlPath: string = this._getFileUrlPath(functionDeclaration);\n\n      apiFunction = new ApiFunction({\n        name,\n        docComment,\n        releaseTag,\n        typeParameters,\n        parameters,\n        overloadIndex,\n        excerptTokens,\n        returnTypeTokenRange,\n        isExported,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiFunction);\n    }\n  }\n\n  private _processApiIndexSignature(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { parentApiItem } = context;\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n    const containerKey: string = ApiIndexSignature.getContainerKey(overloadIndex);\n\n    let apiIndexSignature: ApiIndexSignature | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiIndexSignature;\n\n    if (apiIndexSignature === undefined) {\n      const indexSignature: ts.IndexSignatureDeclaration =\n        astDeclaration.declaration as ts.IndexSignatureDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: indexSignature.type, tokenRange: returnTypeTokenRange });\n\n      const parameters: IApiParameterOptions[] = this._captureParameters(\n        nodesToCapture,\n        indexSignature.parameters\n      );\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const isReadonly: boolean = this._isReadonly(astDeclaration);\n      const fileUrlPath: string = this._getFileUrlPath(indexSignature);\n\n      apiIndexSignature = new ApiIndexSignature({\n        docComment,\n        releaseTag,\n        parameters,\n        overloadIndex,\n        excerptTokens,\n        returnTypeTokenRange,\n        isReadonly,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiIndexSignature);\n    }\n  }\n\n  private _processApiInterface(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { name, isExported, parentApiItem } = context;\n    const containerKey: string = ApiInterface.getContainerKey(name);\n\n    let apiInterface: ApiInterface | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiInterface;\n\n    if (apiInterface === undefined) {\n      const interfaceDeclaration: ts.InterfaceDeclaration =\n        astDeclaration.declaration as ts.InterfaceDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        interfaceDeclaration.typeParameters\n      );\n\n      const extendsTokenRanges: IExcerptTokenRange[] = [];\n\n      for (const heritageClause of interfaceDeclaration.heritageClauses || []) {\n        if (heritageClause.token === ts.SyntaxKind.ExtendsKeyword) {\n          for (const heritageType of heritageClause.types) {\n            const extendsTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n            extendsTokenRanges.push(extendsTokenRange);\n            nodesToCapture.push({ node: heritageType, tokenRange: extendsTokenRange });\n          }\n        }\n      }\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const fileUrlPath: string = this._getFileUrlPath(interfaceDeclaration);\n\n      apiInterface = new ApiInterface({\n        name,\n        docComment,\n        releaseTag,\n        excerptTokens,\n        typeParameters,\n        extendsTokenRanges,\n        isExported,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiInterface);\n    }\n\n    this._processChildDeclarations(astDeclaration, {\n      ...context,\n      parentApiItem: apiInterface\n    });\n  }\n\n  private _processApiMethod(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { name, parentApiItem } = context;\n    const isStatic: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Static) !== 0;\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n    const containerKey: string = ApiMethod.getContainerKey(name, isStatic, overloadIndex);\n\n    let apiMethod: ApiMethod | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiMethod;\n\n    if (apiMethod === undefined) {\n      const methodDeclaration: ts.MethodDeclaration = astDeclaration.declaration as ts.MethodDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: methodDeclaration.type, tokenRange: returnTypeTokenRange });\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        methodDeclaration.typeParameters\n      );\n\n      const parameters: IApiParameterOptions[] = this._captureParameters(\n        nodesToCapture,\n        methodDeclaration.parameters\n      );\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      if (releaseTag === ReleaseTag.Internal || releaseTag === ReleaseTag.Alpha) {\n        return; // trim out items marked as \"@internal\" or \"@alpha\"\n      }\n      const isOptional: boolean =\n        (astDeclaration.astSymbol.followedSymbol.flags & ts.SymbolFlags.Optional) !== 0;\n      const isProtected: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Protected) !== 0;\n      const isAbstract: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Abstract) !== 0;\n      const fileUrlPath: string = this._getFileUrlPath(methodDeclaration);\n\n      apiMethod = new ApiMethod({\n        name,\n        isAbstract,\n        docComment,\n        releaseTag,\n        isProtected,\n        isStatic,\n        isOptional,\n        typeParameters,\n        parameters,\n        overloadIndex,\n        excerptTokens,\n        returnTypeTokenRange,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiMethod);\n    }\n  }\n\n  private _processApiMethodSignature(\n    astDeclaration: AstDeclaration,\n    context: IProcessAstEntityContext\n  ): void {\n    const { name, parentApiItem } = context;\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n    const containerKey: string = ApiMethodSignature.getContainerKey(name, overloadIndex);\n\n    let apiMethodSignature: ApiMethodSignature | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiMethodSignature;\n\n    if (apiMethodSignature === undefined) {\n      const methodSignature: ts.MethodSignature = astDeclaration.declaration as ts.MethodSignature;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: methodSignature.type, tokenRange: returnTypeTokenRange });\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        methodSignature.typeParameters\n      );\n\n      const parameters: IApiParameterOptions[] = this._captureParameters(\n        nodesToCapture,\n        methodSignature.parameters\n      );\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const isOptional: boolean =\n        (astDeclaration.astSymbol.followedSymbol.flags & ts.SymbolFlags.Optional) !== 0;\n      const fileUrlPath: string = this._getFileUrlPath(methodSignature);\n\n      apiMethodSignature = new ApiMethodSignature({\n        name,\n        docComment,\n        releaseTag,\n        isOptional,\n        typeParameters,\n        parameters,\n        overloadIndex,\n        excerptTokens,\n        returnTypeTokenRange,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiMethodSignature);\n    }\n  }\n\n  private _processApiNamespace(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { name, isExported, parentApiItem } = context;\n    const containerKey: string = ApiNamespace.getContainerKey(name);\n\n    let apiNamespace: ApiNamespace | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiNamespace;\n\n    if (apiNamespace === undefined) {\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, []);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const fileUrlPath: string = this._getFileUrlPath(astDeclaration.declaration);\n\n      apiNamespace = new ApiNamespace({\n        name,\n        docComment,\n        releaseTag,\n        excerptTokens,\n        isExported,\n        fileUrlPath\n      });\n      parentApiItem.addMember(apiNamespace);\n    }\n\n    this._processChildDeclarations(astDeclaration, {\n      ...context,\n      parentApiItem: apiNamespace\n    });\n  }\n\n  private _processApiProperty(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { name, parentApiItem } = context;\n    const isStatic: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Static) !== 0;\n    const containerKey: string = ApiProperty.getContainerKey(name, isStatic);\n\n    let apiProperty: ApiProperty | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiProperty;\n\n    if (apiProperty === undefined) {\n      const declaration: ts.Declaration = astDeclaration.declaration;\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const propertyTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      let propertyTypeNode: ts.TypeNode | undefined;\n\n      if (ts.isPropertyDeclaration(declaration) || ts.isGetAccessorDeclaration(declaration)) {\n        propertyTypeNode = declaration.type;\n      }\n\n      if (ts.isSetAccessorDeclaration(declaration)) {\n        // Note that TypeScript always reports an error if a setter does not have exactly one parameter.\n        propertyTypeNode = declaration.parameters[0].type;\n      }\n\n      nodesToCapture.push({ node: propertyTypeNode, tokenRange: propertyTypeTokenRange });\n\n      let initializerTokenRange: IExcerptTokenRange | undefined = undefined;\n      if (ts.isPropertyDeclaration(declaration) && declaration.initializer) {\n        initializerTokenRange = ExcerptBuilder.createEmptyTokenRange();\n        nodesToCapture.push({ node: declaration.initializer, tokenRange: initializerTokenRange });\n      }\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const isOptional: boolean =\n        (astDeclaration.astSymbol.followedSymbol.flags & ts.SymbolFlags.Optional) !== 0;\n      const isProtected: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Protected) !== 0;\n      const isAbstract: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Abstract) !== 0;\n      const isReadonly: boolean = this._isReadonly(astDeclaration);\n      const fileUrlPath: string = this._getFileUrlPath(declaration);\n\n      apiProperty = new ApiProperty({\n        name,\n        docComment,\n        releaseTag,\n        isAbstract,\n        isProtected,\n        isStatic,\n        isOptional,\n        isReadonly,\n        excerptTokens,\n        propertyTypeTokenRange,\n        initializerTokenRange,\n        fileUrlPath\n      });\n      parentApiItem.addMember(apiProperty);\n    } else {\n      // If the property was already declared before (via a merged interface declaration),\n      // we assume its signature is identical, because the language requires that.\n    }\n  }\n\n  private _processApiPropertySignature(\n    astDeclaration: AstDeclaration,\n    context: IProcessAstEntityContext\n  ): void {\n    const { name, parentApiItem } = context;\n    const containerKey: string = ApiPropertySignature.getContainerKey(name);\n\n    let apiPropertySignature: ApiPropertySignature | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiPropertySignature;\n\n    if (apiPropertySignature === undefined) {\n      const propertySignature: ts.PropertySignature = astDeclaration.declaration as ts.PropertySignature;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const propertyTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: propertySignature.type, tokenRange: propertyTypeTokenRange });\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const isOptional: boolean =\n        (astDeclaration.astSymbol.followedSymbol.flags & ts.SymbolFlags.Optional) !== 0;\n      const isReadonly: boolean = this._isReadonly(astDeclaration);\n      const fileUrlPath: string = this._getFileUrlPath(propertySignature);\n\n      apiPropertySignature = new ApiPropertySignature({\n        name,\n        docComment,\n        releaseTag,\n        isOptional,\n        excerptTokens,\n        propertyTypeTokenRange,\n        isReadonly,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiPropertySignature);\n    } else {\n      // If the property was already declared before (via a merged interface declaration),\n      // we assume its signature is identical, because the language requires that.\n    }\n  }\n\n  private _processApiTypeAlias(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { name, isExported, parentApiItem } = context;\n\n    const containerKey: string = ApiTypeAlias.getContainerKey(name);\n\n    let apiTypeAlias: ApiTypeAlias | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiTypeAlias;\n\n    if (apiTypeAlias === undefined) {\n      const typeAliasDeclaration: ts.TypeAliasDeclaration =\n        astDeclaration.declaration as ts.TypeAliasDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        typeAliasDeclaration.typeParameters\n      );\n\n      const typeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: typeAliasDeclaration.type, tokenRange: typeTokenRange });\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const fileUrlPath: string = this._getFileUrlPath(typeAliasDeclaration);\n\n      apiTypeAlias = new ApiTypeAlias({\n        name,\n        docComment,\n        typeParameters,\n        releaseTag,\n        excerptTokens,\n        typeTokenRange,\n        isExported,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiTypeAlias);\n    }\n  }\n\n  private _processApiVariable(astDeclaration: AstDeclaration, context: IProcessAstEntityContext): void {\n    const { name, isExported, parentApiItem } = context;\n\n    const containerKey: string = ApiVariable.getContainerKey(name);\n\n    let apiVariable: ApiVariable | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiVariable;\n\n    if (apiVariable === undefined) {\n      const variableDeclaration: ts.VariableDeclaration =\n        astDeclaration.declaration as ts.VariableDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const variableTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: variableDeclaration.type, tokenRange: variableTypeTokenRange });\n\n      let initializerTokenRange: IExcerptTokenRange | undefined = undefined;\n      if (variableDeclaration.initializer) {\n        initializerTokenRange = ExcerptBuilder.createEmptyTokenRange();\n        nodesToCapture.push({ node: variableDeclaration.initializer, tokenRange: initializerTokenRange });\n      }\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const isReadonly: boolean = this._isReadonly(astDeclaration);\n      const fileUrlPath: string = this._getFileUrlPath(variableDeclaration);\n\n      apiVariable = new ApiVariable({\n        name,\n        docComment,\n        releaseTag,\n        excerptTokens,\n        variableTypeTokenRange,\n        initializerTokenRange,\n        isReadonly,\n        isExported,\n        fileUrlPath\n      });\n\n      parentApiItem.addMember(apiVariable);\n    }\n  }\n\n  /**\n   * @param nodesToCapture - A list of child nodes whose token ranges we want to capture\n   */\n  private _buildExcerptTokens(\n    astDeclaration: AstDeclaration,\n    nodesToCapture: IExcerptBuilderNodeToCapture[]\n  ): IExcerptToken[] {\n    const excerptTokens: IExcerptToken[] = [];\n\n    // Build the main declaration\n    ExcerptBuilder.addDeclaration(excerptTokens, astDeclaration, nodesToCapture, this._referenceGenerator);\n\n    const declarationMetadata: DeclarationMetadata = this._collector.fetchDeclarationMetadata(astDeclaration);\n\n    // Add any ancillary declarations\n    for (const ancillaryDeclaration of declarationMetadata.ancillaryDeclarations) {\n      ExcerptBuilder.addBlankLine(excerptTokens);\n      ExcerptBuilder.addDeclaration(\n        excerptTokens,\n        ancillaryDeclaration,\n        nodesToCapture,\n        this._referenceGenerator\n      );\n    }\n\n    return excerptTokens;\n  }\n\n  private _captureTypeParameters(\n    nodesToCapture: IExcerptBuilderNodeToCapture[],\n    typeParameterNodes: ts.NodeArray<ts.TypeParameterDeclaration> | undefined\n  ): IApiTypeParameterOptions[] {\n    const typeParameters: IApiTypeParameterOptions[] = [];\n    if (typeParameterNodes) {\n      for (const typeParameter of typeParameterNodes) {\n        const constraintTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n        nodesToCapture.push({ node: typeParameter.constraint, tokenRange: constraintTokenRange });\n\n        const defaultTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n        nodesToCapture.push({ node: typeParameter.default, tokenRange: defaultTypeTokenRange });\n\n        typeParameters.push({\n          typeParameterName: typeParameter.name.getText().trim(),\n          constraintTokenRange,\n          defaultTypeTokenRange\n        });\n      }\n    }\n    return typeParameters;\n  }\n\n  private _captureParameters(\n    nodesToCapture: IExcerptBuilderNodeToCapture[],\n    parameterNodes: ts.NodeArray<ts.ParameterDeclaration>\n  ): IApiParameterOptions[] {\n    const parameters: IApiParameterOptions[] = [];\n    for (const parameter of parameterNodes) {\n      const parameterTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: parameter.type, tokenRange: parameterTypeTokenRange });\n      parameters.push({\n        parameterName: parameter.name.getText().trim(),\n        parameterTypeTokenRange,\n        isOptional: this._collector.typeChecker.isOptionalParameter(parameter)\n      });\n    }\n    return parameters;\n  }\n\n  private _isReadonly(astDeclaration: AstDeclaration): boolean {\n    switch (astDeclaration.declaration.kind) {\n      case ts.SyntaxKind.GetAccessor:\n      case ts.SyntaxKind.IndexSignature:\n      case ts.SyntaxKind.PropertyDeclaration:\n      case ts.SyntaxKind.PropertySignature:\n      case ts.SyntaxKind.SetAccessor:\n      case ts.SyntaxKind.VariableDeclaration: {\n        const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n        const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n        const declarationMetadata: DeclarationMetadata =\n          this._collector.fetchDeclarationMetadata(astDeclaration);\n\n        const hasReadonlyModifier: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Readonly) !== 0;\n        const hasReadonlyDocTag: boolean = !!docComment?.modifierTagSet?.hasTagName('@readonly');\n        const isGetterWithNoSetter: boolean =\n          ts.isGetAccessorDeclaration(astDeclaration.declaration) &&\n          declarationMetadata.ancillaryDeclarations.length === 0;\n        const isVarConst: boolean =\n          ts.isVariableDeclaration(astDeclaration.declaration) &&\n          TypeScriptInternals.isVarConst(astDeclaration.declaration);\n\n        return hasReadonlyModifier || hasReadonlyDocTag || isGetterWithNoSetter || isVarConst;\n      }\n      default: {\n        // Readonly-ness does not make sense for any other declaration kind.\n        return false;\n      }\n    }\n  }\n\n  private _getFileUrlPath(declaration: ts.Declaration): string {\n    const sourceFile: ts.SourceFile = declaration.getSourceFile();\n    const sourceLocation: ISourceLocation = this._collector.sourceMapper.getSourceLocation({\n      sourceFile,\n      pos: declaration.pos\n    });\n\n    let result: string = path.relative(\n      this._collector.extractorConfig.projectFolder,\n      sourceLocation.sourceFilePath\n    );\n    result = Path.convertToSlashes(result);\n    return result;\n  }\n}\n"]}