{"version":3,"file":"ExperimentalYamlDocumenter.js","sourceRoot":"","sources":["../../src/documenters/ExperimentalYamlDocumenter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { type DocComment, DocInlineTag } from '@microsoft/tsdoc';\nimport { type ApiModel, type ApiItem, ApiItemKind, ApiDocumentedItem } from '@microsoft/api-extractor-model';\n\nimport type { IConfigTableOfContents } from './IConfigFile';\nimport type { IYamlTocItem, IYamlTocFile } from '../yaml/IYamlTocFile';\nimport { YamlDocumenter } from './YamlDocumenter';\nimport type { DocumenterConfig } from './DocumenterConfig';\n\n/**\n * EXPERIMENTAL - This documenter is a prototype of a new config file driven mode of operation for\n * API Documenter.  It is not ready for general usage yet.  Its design may change in the future.\n */\nexport class ExperimentalYamlDocumenter extends YamlDocumenter {\n  private _config: IConfigTableOfContents;\n  private _tocPointerMap: { [key: string]: IYamlTocItem };\n  private _catchAllPointer: IYamlTocItem | undefined;\n\n  public constructor(apiModel: ApiModel, documenterConfig: DocumenterConfig) {\n    super(apiModel, documenterConfig.configFile.newDocfxNamespaces);\n    this._config = documenterConfig.configFile.tableOfContents!;\n\n    this._tocPointerMap = {};\n\n    this._generateTocPointersMap(this._config.tocConfig);\n  }\n\n  /** @override */\n  protected buildYamlTocFile(apiItems: ReadonlyArray<ApiItem>): IYamlTocFile {\n    this._buildTocItems2(apiItems);\n    return this._config.tocConfig;\n  }\n\n  private _buildTocItems2(apiItems: ReadonlyArray<ApiItem>): IYamlTocItem[] {\n    const tocItems: IYamlTocItem[] = [];\n    for (const apiItem of apiItems) {\n      let tocItem: IYamlTocItem;\n      if (apiItem.kind === ApiItemKind.Namespace && !this.newDocfxNamespaces) {\n        tocItem = {\n          name: this._getTocItemName(apiItem)\n        };\n      } else {\n        if (this._shouldEmbed(apiItem.kind)) {\n          // Don't generate table of contents items for embedded definitions\n          continue;\n        }\n\n        tocItem = {\n          name: this._getTocItemName(apiItem),\n          uid: this._getUid(apiItem)\n        };\n\n        if (apiItem.kind !== ApiItemKind.Package) {\n          this._filterItem(apiItem, tocItem);\n        }\n      }\n\n      tocItems.push(tocItem);\n\n      const children: ApiItem[] = this._getLogicalChildren(apiItem);\n      const childItems: IYamlTocItem[] = this._buildTocItems2(children);\n      if (childItems.length > 0) {\n        tocItem.items = childItems;\n      }\n    }\n    return tocItems;\n  }\n\n  // Parses the tocConfig object to build a pointers map of nodes where we want to sort out the API items\n  private _generateTocPointersMap(tocConfig: IYamlTocFile | IYamlTocItem): void {\n    const { catchAllCategory } = this._config;\n\n    if (tocConfig.items) {\n      for (const tocItem of tocConfig.items) {\n        if (tocItem.items && tocItem.items.length > 0 && this._shouldNotIncludeInPointersMap(tocItem)) {\n          this._generateTocPointersMap(tocItem);\n        } else {\n          // check for presence of the `catchAllCategory` config option\n          if (catchAllCategory && tocItem.name === catchAllCategory) {\n            this._catchAllPointer = tocItem;\n          } else {\n            this._tocPointerMap[tocItem.name] = tocItem;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Filtering out the api-item by inlineTags or category name presence in the item name.\n   */\n  private _filterItem(apiItem: ApiItem, tocItem: IYamlTocItem): void {\n    const { categoryInlineTag, categorizeByName } = this._config;\n    const { name: itemName } = tocItem;\n    let filtered: boolean = false;\n\n    // First we attempt to filter by inline tag if provided.\n    if (apiItem instanceof ApiDocumentedItem) {\n      const docInlineTag: DocInlineTag | undefined = categoryInlineTag\n        ? this._findInlineTagByName(categoryInlineTag, apiItem.tsdocComment)\n        : undefined;\n\n      const tagContent: string | undefined =\n        docInlineTag && docInlineTag.tagContent && docInlineTag.tagContent.trim();\n\n      if (tagContent && this._tocPointerMap[tagContent]) {\n        // null assertion used because when pointer map was created we checked for presence of empty `items` array\n        this._tocPointerMap[tagContent].items!.push(tocItem);\n        filtered = true;\n      }\n    }\n\n    // If not filtered by inline tag and `categorizeByName` config is enabled attempt to filter it by category name.\n    if (!filtered && categorizeByName) {\n      const pointers: string[] = Object.keys(this._tocPointerMap);\n      for (let i: number = 0, length: number = pointers.length; i < length; i++) {\n        if (itemName.indexOf(pointers[i]) !== -1) {\n          // null assertion used because when pointer map was created we checked for presence of empty `items` array\n          this._tocPointerMap[pointers[i]].items!.push(tocItem);\n          filtered = true;\n          break;\n        }\n      }\n    }\n\n    // If item still not filtered and a `catchAllCategory` config provided push it to it.\n    if (!filtered && this._catchAllPointer && this._catchAllPointer.items) {\n      this._catchAllPointer.items.push(tocItem);\n    }\n  }\n\n  // This is a direct copy of a @docCategory inline tag finder in office-ui-fabric-react,\n  // but is generic enough to be used for any inline tag\n  private _findInlineTagByName(\n    tagName: string,\n    docComment: DocComment | undefined\n  ): DocInlineTag | undefined {\n    const tagNameToCheck: string = `@${tagName}`;\n\n    if (docComment instanceof DocInlineTag) {\n      if (docComment.tagName === tagNameToCheck) {\n        return docComment;\n      }\n    }\n    if (docComment) {\n      for (const childNode of docComment.getChildNodes()) {\n        const result: DocInlineTag | undefined = this._findInlineTagByName(tagName, childNode as DocComment);\n        if (result !== undefined) {\n          return result;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  private _shouldNotIncludeInPointersMap(item: IYamlTocItem): boolean {\n    const { nonEmptyCategoryNodeNames } = this._config;\n    if (nonEmptyCategoryNodeNames && nonEmptyCategoryNodeNames.length) {\n      return nonEmptyCategoryNodeNames.indexOf(item.name) === -1;\n    }\n    return true;\n  }\n}\n"]}