"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.newProtocolConnection = exports.spawnWithWebSocket = exports.spawnWithPipe = exports.spawnChrome = void 0;
const protocol_connection_1 = require("@tracerbench/protocol-connection");
const spawn_1 = require("@tracerbench/spawn");
const spawn_chrome_1 = require("@tracerbench/spawn-chrome");
const websocket_message_transport_1 = require("@tracerbench/websocket-message-transport");
const debug = require("debug");
const events_1 = require("events");
const race_cancellation_1 = require("race-cancellation");
const debugSpawn = debug("chrome-debugging-client:spawn");
const debugTransport = debug("chrome-debugging-client:transport");
function spawnChrome(options) {
    return attachPipeTransport(spawn_chrome_1.default(options, debugSpawn));
}
exports.spawnChrome = spawnChrome;
function spawnWithPipe(executable, args, stdio) {
    return attachPipeTransport(spawn_1.default(executable, args, stdio, "pipe", debugSpawn));
}
exports.spawnWithPipe = spawnWithPipe;
async function spawnWithWebSocket(executable, args, stdio, raceCancellation) {
    const process = spawn_1.default(executable, args, stdio, "websocket", debugSpawn);
    const url = await process.url(raceCancellation);
    const [attach, close] = await websocket_message_transport_1.default(url, race_cancellation_1.combineRaceCancellation(process.raceExit, raceCancellation));
    const connection = newProtocolConnection(attach, process.raceExit);
    return Object.assign(process, { connection, close });
}
exports.spawnWithWebSocket = spawnWithWebSocket;
function newProtocolConnection(attach, raceCancellation) {
    return protocol_connection_1.default(attach, () => new events_1.EventEmitter(), debugTransport, raceCancellation);
}
exports.newProtocolConnection = newProtocolConnection;
var websocket_message_transport_2 = require("@tracerbench/websocket-message-transport");
Object.defineProperty(exports, "openWebSocket", { enumerable: true, get: function () { return websocket_message_transport_2.default; } });
var find_chrome_1 = require("@tracerbench/find-chrome");
Object.defineProperty(exports, "findChrome", { enumerable: true, get: function () { return find_chrome_1.default; } });
function attachPipeTransport(process) {
    const connection = newProtocolConnection(process.attach, process.raceExit);
    return Object.assign(process, { close, connection });
    async function close(timeout, raceCancellation) {
        if (process.hasExited()) {
            return;
        }
        try {
            const waitForExit = process.waitForExit(timeout, raceCancellation);
            await Promise.race([waitForExit, sendBrowserClose()]);
            // double check in case send() won the race which is most of the time
            // sometimes chrome exits before send() gets a response
            await waitForExit;
        }
        catch (e) {
            // if we closed then we dont really care what the error is
            if (!process.hasExited()) {
                throw e;
            }
        }
    }
    async function sendBrowserClose() {
        try {
            await connection.send("Browser.close");
        }
        catch (e) {
            // the browser sometimes closes the connection before sending
            // the response which will cancel the send
            if (!race_cancellation_1.isCancellation(e)) {
                throw e;
            }
        }
    }
}
//# sourceMappingURL=index.js.map