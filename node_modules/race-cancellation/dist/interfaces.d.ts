/**
 * A symbol that brands a Cancellation.
 *
 * This symbol is a runtime registered symbol so that if multiple
 * versions of the module are loaded it interops.
 *
 * So that for an unknown x
 * `typeof x === "object" && x !== null && Symbol.for("isCancellation") in x`
 */
export declare const cancellationBrand: unique symbol;
export declare const enum CancellationKind {
    /**
     * General cancellation request.
     */
    Cancellation = "Cancellation",
    /**
     * The task timed out.
     */
    Timeout = "Timeout",
    /**
     * A concurrent branch was the winner in a `Promise.race`
     * or failed in a `Promise.all`
     */
    ShortCircuit = "ShortCircuit"
}
export interface Cancellation<Kind extends string = string> {
    [cancellationBrand]: true;
    kind: Kind;
    message: string;
}
export declare type Complete<Result> = (result: Result) => void;
export declare type RaceCancellation = <Result>(task: Task<Result> | PromiseLike<Result>) => Promise<Result | Cancellation>;
export declare type NewCancellation = () => Cancellation;
export declare type Task<Result> = () => PromiseLike<Result>;
export declare type CancellableTask<Result> = (raceCancellation: RaceCancellation) => Promise<Result | Cancellation>;
export declare type OptionallyCancellableTask<Result> = (raceCancellation?: RaceCancellation) => Promise<Result | Cancellation>;
export declare type Cancel = (message?: string, kind?: string) => void;
export declare type CancellableRace = [RaceCancellation, Cancel];
export declare type Executor<Result> = (resolve: (value?: Result | PromiseLike<Result>) => void, reject: (reason?: any) => void) => Dispose;
export declare type Dispose = () => void;
export declare type NewTimeout = (callback: () => void, ms: number) => Dispose;
export declare type NewTimeoutCancellation = () => Cancellation<CancellationKind.Timeout>;
